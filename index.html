<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JetSurfers 2</title>
    <script src="snowfall_effect.js"></script>
    <link rel="icon" href="rec/xmas-icon.jpg" type="image/png">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Styles for Game Canvas and UI */
        body {
            font-family: 'Inter', sans-serif;
            background-color: red; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
        }
        #gameContainer {
            width: 100%;
            max-width: 450px; /* Default for mobile/small screen */
            aspect-ratio: 9/16; /* Standard mobile aspect ratio */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(180deg, #1f2937 0%, #111827 100%); /* Darker gradient for the structure */
            position: relative;
        }

        /* Desktop specific styles for larger canvas */
        @media (min-width: 768px) {
            #gameContainer {
                max-width: 600px; /* Bigger size for desktop */
            }
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(0deg, #fcffff 0%, #dfe0e2 100%); /* Deep night sky gradient */
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            /* Allows touches to pass through the UI elements to the canvas */
            pointer-events: none;
        }
        .top-bar {
            position: absolute;
            top: 15px;
            /* Adjusted width and positioning to avoid collision with pause button */
            width: calc(100% - 30px); 
            display: flex;
            justify-content: flex-end; /* Align elements to the right */
            align-items: center;
            color: #f3f4f6;
            font-weight: bold;
            font-size: 1rem;
            padding: 0 15px;
        }
        .score-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            min-width: 80px; /* Ensure boxes are readable */
            justify-content: center;
            margin-left: 10px; /* Spacing between the three score/coin boxes */
        }
        .coin-icon {
            /* Now an image, not a star text */
            width: 18px; 
            height: 18px;
            margin-right: 6px;
            /* Added object-fit for visual consistency */
            object-fit: contain; 
        }
        .modal {
            background: rgba(17, 24, 39, 0.98);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.8);
            border: 2px solid #3b82f6;
            pointer-events: auto; /* Re-enable pointer events for the modal */
            max-width: 90%; /* Allow modal to be slightly wider for shop */
            width: 400px;
            max-height: 90vh; /* Ensure modal fits on screen */
            overflow-y: auto; /* Allow scrolling if content is too tall */
            z-index: 20; /* Ensure modal is on top */
        }
        
        .game-button {
            padding: 10px 25px;
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            background-color: #3b82f6;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #1e40af;
        }
        .game-button:hover {
            background-color: #2563eb;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #1e40af;
        }

        /* --- Magnet Progress Bar Styles --- */
        #magnetProgressContainer {
            position: absolute;
            top: 60px; /* Below the top score bar */
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 16px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s;
            pointer-events: none;
            display: flex;
            align-items: center;
            padding: 0 4px;
        }
        #magnetProgressBar {
            height: 100%;
            background: linear-gradient(90deg, #60a5fa, #3b82f6); /* Blue gradient */
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 6px;
        }
        #magnetIcon {
            position: absolute;
            left: 8px;
            color: white;
            font-size: 0.9rem;
            z-index: 2;
        }

        /* --- Pause Button Styles --- */
        .pause-button {
            pointer-events: auto; /* Allow clicks */
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: background-color 0.15s;
            border: none; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .pause-button img {
            width: 20px;
            height: 20px;
            display: block;
            margin: 0;
        }
        
        /* --- Menu Button Styles for Pause Modal --- */
        .menu-button {
            display: block; /* Changed from width: 100% to ensure <a> tag behaves same */
            width: 100%;
            padding: 12px 0;
            margin: 8px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f3f4f6;
            background-color: #1f2937; /* Darker blue/gray */
            border: 2px solid #3b82f6;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px #111827;
            text-decoration: none; /* Added for <a> tag */
            text-align: center; /* Added for <a> tag */
        }

        .menu-button:hover {
            background-color: #374151;
        }

        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #111827;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay for Score and Modals -->
    <div class="ui-overlay">
        
        <!-- Pause Button (Positioned top left) -->
        <button id="pauseButton" class="pause-button absolute top-4 left-4 z-10 hidden">
            <!-- Updated to use a PNG image for better styling -->
            <img src="rec/icons/pause_icon.png" alt="Pause" class="w-5 h-5" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHJlY3Qgd2lkdGg9IjE4IiBoZWlnaHQ9IjUwIiBmaWxsPSIjZmZmZmZmIi8+PHJlY3QgeD0iMjciIHdpZHRoPSIxOCIgaGVpZ2h0PSI1MCIgZmlsbD0iI2ZmZmZmZiIvPjwvc3ZnPg=='">
        </button>
        
        <!-- Top Bar for Score and Coins -->
        <div class="top-bar">
            <!-- Score Display -->
            <div class="score-box">
                Score: <span id="scoreValue">0</span> m
            </div>
            <!-- Current Run Coins -->
            <div class="score-box">
                <!-- Replaced star icon with image tag -->
                <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHBhdGggZD0iTTUwLDI1QzUwLDE3LjUsNDIuNSwxMCwzNSwxMEMyNy41LDEwLDIwLDE3LjUsMjAsMjVDMjAsMzIuNSwyNy41LDQwLDM1LDQwQzQyLjUsNDAsNTAsMzIuNSw1MCwyNU0xNSwxMEM3LjUsMTAsMCwxNy41LDAsMjVDMCwzMi41LDcuNSw0MCwxNSw0MEMyMi41LDQwLDMwLDMyLjUsMzAsMjVDMzAsMTcuNSwyMi41LDEwLDE1LDEwWiIgZmlsbD0iI2ZhY2MxNSIvPjwvc3ZnPg=='"> 
                <span id="runCoinsValue">0</span>
            </div>
            <!-- Total Persistent Coins -->
            <div class="score-box">
                <!-- Replaced star icon with image tag -->
                <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHBhdGggZD0iTTUwLDI1QzUwLDE3LjUsNDIuNSwxMCwzNSwxMEMyNy41LDEwLDIwLDE3LjUsMjAsMjVDMjAsMzIuNSwyNy41LDQwLDM1LDQwQzQyLjUsNDAsNTAsMzIuNSw1MCwyNU0xNSwxMEM3LjUsMTAsMCwxNy41LDAsMjVDMCwzMi41LDcuNSw0MCwxNSw0MEMyMi41LDQwLDMwLDMyLjUsMzAsMjVDMzAsMTcuNSwyMi41LDEwLDE1LDEwWiIgZmlsbD0iI2ZhY2MxNSIvPjwvc3ZnPg=='">
                Total Coins: <span id="totalCoinsValue">0</span>
            </div>
        </div>

        <!-- Magnet Progress Bar -->
        <div id="magnetProgressContainer" class="opacity-0">
            <span id="magnetIcon">ðŸ§²</span>
            <div id="magnetProgressBar"></div>
        </div>


        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <h1 id="modalTitle" class="text-3xl font-extrabold mb-4 text-cyan-400">JET SURFERS II</h1>
            <p id="modalMessage" class="text-lg mb-6">
                Collect coins and avoid oncoming aircrafts.
            </p>
            <p class="text-sm mb-6 text-gray-300">
                Controls:<br>
                Desktop: A or Left Arrow / D or Right Arrow<br>
                Mobile: Tap Left / Right side of the screen
            </p>
            <button id="startButton" class="game-button">START FLIGHT</button>
            <div id="finalScore" class="text-xl font-bold mt-4 hidden"></div>
            <div id="coinsEarned" class="text-xl font-bold text-yellow-400 mt-2 hidden"></div>
        </div>

        <!-- Pause Menu Modal -->
        <div id="pauseMenuModal" class="modal hidden">
            <h2 class="text-3xl font-extrabold mb-8 text-white">PAUSED</h2>
            <button id="resumeButton" class="menu-button">RESUME FLIGHT</button>
            <button id="shopButton" class="menu-button">UPGRADES SHOP</button>
            <!-- UPDATED: This is now a link to shop.html -->
            <a href="jetshop.html" id="jetShopMenuButton" class="menu-button">JET SHOP</a>
            <button id="settingsButton" class="menu-button">SETTINGS</button>
            <p class="text-xs text-gray-500 mt-6">Game Version: v1.0.0</p>
        </div>

        <!-- Jet Shop Modal has been removed from this file -->

    </div>
</div>

<script>
    // --- Local Storage Setup (Shared Keys) ---
    // These keys are shared with shop.html
    const COIN_STORAGE_KEY = 'jetSurferTotalCoins';
    const MAGNET_LEVEL_KEY = 'jetSurferMagnetLevel'; // Match shop.html key
    const JET_OWNED_KEY = 'jetSurferOwnedJets';
    const JET_SELECTED_KEY = 'jetSurferSelectedJet';
    // --- END: Added Jet Storage Keys ---

    // --- START: Jet Definitions ---
    // This array MUST match the one in shop.html
    const JETS = [
        { id: 'default', name: 'Standard Issue', price: 0, img: 'rec/motor/default.png' },
        { id: 'blue_streak', name: 'Blue Streak', price: 500, img: 'rec/motor/jet_blue.png' }, // Placeholder
        { id: 'red_comet', name: 'Nightwing', price: 1000, img: 'rec/motor/nightwing.png' }, // Placeholder
        { id: 'gold_wing', name: 'Premium Jet', price: 5000, img: 'rec/motor/premium-jet.png' } // Placeholder
    ];
    const DEFAULT_JET_ID = 'default';
    
    let ownedJets = [DEFAULT_JET_ID];
    let selectedJetId = DEFAULT_JET_ID;
    // --- END: Jet Definitions ---

    let totalCoins = 0; // The persistent total
    let magnetLevel = 0; // The persistent magnet level (0 to 5)

    function loadGameData() {
        const storedCoins = localStorage.getItem(COIN_STORAGE_KEY);
        totalCoins = storedCoins ? parseInt(storedCoins, 10) : 0;
        
        const storedMagnetLevel = localStorage.getItem(MAGNET_LEVEL_KEY);
        magnetLevel = storedMagnetLevel ? parseInt(storedMagnetLevel, 10) : 0;
        
        document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();

        // --- Load Jet Data ---
        const storedOwnedJets = localStorage.getItem(JET_OWNED_KEY);
        ownedJets = storedOwnedJets ? JSON.parse(storedOwnedJets) : [DEFAULT_JET_ID];

        const storedSelectedJet = localStorage.getItem(JET_SELECTED_KEY);
        selectedJetId = storedSelectedJet ? storedSelectedJet : DEFAULT_JET_ID;
        
        // Apply the selected jet image
        const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
        playerImg.src = selectedJet.img;
    }

    function saveCoins(coinsEarned) {
        if (coinsEarned > 0) {
            totalCoins += coinsEarned;
        }
        localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
        document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
        
        // Removed update to jetShopCoinsValue as it no longer exists here
    }
    
    // --- Jet/Coin Functions (Still needed for loading) ---
    // This function is only used by shop.html now, but we keep
    // saveOwnedJets and saveSelectedJet in case we add logic
    // to unlock jets via gameplay later.
    function spendCoins(amount) {
        if (totalCoins >= amount) {
            totalCoins -= amount;
            localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
            document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
            return true; // Purchase successful
        }
        return false; // Not enough coins
    }

    function saveOwnedJets() {
        localStorage.setItem(JET_OWNED_KEY, JSON.stringify(ownedJets));
    }

    function saveSelectedJet() {
        localStorage.setItem(JET_SELECTED_KEY, selectedJetId);
        // Also update the playerImg.src immediately
        const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
        playerImg.src = selectedJet.img;
        playerImg.isLoaded = false; // Force reload
        playerImg.onload = () => { playerImg.isLoaded = true; };
    }
    // --- End: Jet/Coin Functions ---

    function saveMagnetLevel(newLevel) {
        magnetLevel = newLevel;
        localStorage.setItem(MAGNET_LEVEL_KEY, newLevel);
        updateMagnetDuration(); // Recalculate duration when level changes
    }


    // --- Canvas Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');

    // UI Elements
    const scoreValueElement = document.getElementById('scoreValue');
    const runCoinsValueElement = document.getElementById('runCoinsValue');
    const totalCoinsValueElement = document.getElementById('totalCoinsValue');
    const gameModal = document.getElementById('gameModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const startButton = document.getElementById('startButton');
    const finalScore = document.getElementById('finalScore');
    const coinsEarned = document.getElementById('coinsEarned');

    // UI Elements for Pause Menu
    const pauseButton = document.getElementById('pauseButton');
    const pauseMenuModal = document.getElementById('pauseMenuModal');
    const resumeButton = document.getElementById('resumeButton');
    const shopButton = document.getElementById('shopButton');
    const settingsButton = document.getElementById('settingsButton');

    // --- Jet Shop UI Elements (REMOVED) ---
    // const jetShopMenuButton = document.getElementById('jetShopMenuButton'); // This is an <a> tag now
    // const jetShopModal = document.getElementById('jetShopModal');
    // const jetShopCoinsValue = document.getElementById('jetShopCoinsValue');
    // const jetShopGrid = document.getElementById('jetShopGrid');
    // const jetShopBackButton = document.getElementById('jetShopBackButton');
    // --- End: Jet Shop UI Elements (REMOVED) ---
    
    // NEW UI ELEMENTS for Magnet
    const magnetProgressContainer = document.getElementById('magnetProgressContainer');
    const magnetProgressBar = document.getElementById('magnetProgressBar');

    // Game Constants
    const NUM_LANES = 3;
    const LANE_WIDTH_PERCENTAGE = 0.25;
    const PLAYER_SIZE = 60;
    const COLLISION_SIZE_RATIO = 0.7;
    const PLAYER_Y_POS_RATIO = 0.8;
    const PLAYER_MOVE_SPEED = 0.15;
    const INITIAL_GAME_SPEED = 4;
    const SPEED_INCREMENT_SCORE = 1000;
    const SPEED_INCREMENT_AMOUNT = 0.02;

    // Magnet State Variables and Constants
    const MAGNET_DURATION_SECONDS_BASE = 10; // Base duration
    const MAGNET_DURATION_BONUS_PER_LEVEL = 2; // +2 seconds per level
    const MAGNET_MAX_LEVEL = 5;
    
    let currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE; // Actual duration used in game
    
    const MAGNET_BOOST_MULTIPLIER = 3.5;
    const MAGNET_SLOWDOWN_TIME_SECONDS = 2; 
    const MAGNET_SPAWN_CHANCE = 0.05; 

    // Dynamic Magnet Duration Calculation
    function updateMagnetDuration() {
        currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE + (magnetLevel * MAGNET_DURATION_BONUS_PER_LEVEL);
    }
    
    // Initial calculation (must be called after loading magnetLevel)
    updateMagnetDuration(); 


    // State variables
    let gameState = 'START'; // Possible states: 'START', 'PLAYING', 'PAUSED', 'SHAKING', 'GAMEOVER'
    let score = 0;
    let runCoins = 0;
    let baseGameSpeed = INITIAL_GAME_SPEED;
    let currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
    let lastTime = 0;
    let deltaTime = 0;
    let lastObstacleTime = 0;
    let currentLane = 1;
    let targetLane = 1;
    let playerX = 0;
    let obstacles = [];
    let speedLevel = 0;

    let isMagnetActive = false;
    let magnetDurationMS = 0; // duration in milliseconds, set on activation
    let magnetStartTime = 0;
    let isSlowingDown = false;
    
    let shakeEndTime = 0;
    const SHAKE_MAGNITUDE = 10;
    const SHAKE_DURATION = 300;

    // Player/Coin Images
    const playerImg = new Image();
    // playerImg.src is set by loadGameData()
    playerImg.isLoaded = false;
    playerImg.onload = () => { playerImg.isLoaded = true; };
    playerImg.onerror = () => { 
        console.error("Failed to load selected jet image. Loading default.");
        playerImg.src = 'rec/motor/default.png'; // Fallback
        playerImg.isLoaded = false; // Re-trigger onload
        playerImg.onload = () => { playerImg.isLoaded = true; };
    };

    const coinImg = new Image();
    coinImg.src = "rec/items/coin.png"; 
    coinImg.isLoaded = false;
    coinImg.onload = () => { coinImg.isLoaded = true; };
    coinImg.onerror = () => { console.error("Failed to load coin image."); };
    
    const magnetImg = new Image();
    magnetImg.src = "rec/collectible/magnet.png"; 
    magnetImg.isLoaded = false;
    magnetImg.onload = () => { magnetImg.isLoaded = true; };
    magnetImg.onerror = () => { console.error("Failed to load magnet image. Using fallback."); };

    // --- Audio Setup (Unchanged) ---
    const coinSound = new Audio('sfx/coin.mp3');
    const deathSound = new Audio('sfx/dead.mp3');
    const powerupSound = new Audio('sfx/powerup.mp3'); 

    coinSound.volume = 0.5; 
    deathSound.volume = 0.5;
    powerupSound.volume = 0.6;

    function playCoinSound() {
        coinSound.currentTime = 0; 
        coinSound.play().catch(e => console.error("Coin audio playback failed (expected if MP3 is missing):", e));
    }

    function playDeathSound() {
        deathSound.currentTime = 0; 
        deathSound.play().catch(e => console.error("Death audio playback failed (expected if MP3 is missing):", e));
    }

    function playPowerupSound() {
        powerupSound.currentTime = 0;
        powerupSound.play().catch(e => console.error("Powerup audio playback failed (expected if MP3 is missing):", e));
    }


    // --- Object Classes (Unchanged) ---

    class Obstacle {
        constructor(lane, size, type = 'enemy') {
            this.lane = lane;
            this.size = size;
            this.y = -size;
            this.type = type;
            this.isHit = false;
        }

        update(speed, dt) {
            this.y += speed * dt;
        }

        draw(ctx, lanePos) {
            const xCenter = lanePos[this.lane];
            const y = this.y;

            if (this.type === 'enemy') {
                // Enemy Plane (Red/Black)
                ctx.fillStyle = this.isHit ? 'rgba(255, 0, 0, 0.8)' : 'rgba(239, 68, 68, 0.9)';
                ctx.beginPath();
                // Simple delta wing shape
                ctx.moveTo(xCenter, y);
                ctx.lineTo(xCenter - this.size / 2, y + this.size);
                ctx.lineTo(xCenter + this.size / 2, y + this.size);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(xCenter - this.size * 0.1, y + this.size * 0.2, this.size * 0.2, this.size * 0.5); // Cockpit
            } else if (this.type === 'coin') {
                // Coin
                if (coinImg.isLoaded) {
                    ctx.drawImage(coinImg, xCenter - this.size / 2, y, this.size, this.size);
                } else {
                    ctx.fillStyle = '#FFEB3B';
                    ctx.beginPath();
                    ctx.arc(xCenter, y + this.size / 2, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (this.type === 'magnet') {
                 // Magnet Power-up
                if (magnetImg.isLoaded) {
                    // Draw image if loaded
                    ctx.drawImage(magnetImg, xCenter - this.size / 2, y, this.size, this.size);
                } else {
                    // Fallback to a purple square with an icon
                    ctx.fillStyle = '#9333ea'; // Deep Purple
                    ctx.fillRect(xCenter - this.size / 2, y, this.size, this.size);
                    ctx.fillStyle = 'white';
                    ctx.font = `${this.size * 0.6}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ðŸ§²', xCenter, y + this.size / 2 + 2);
                }
            }
        }

        getBounds(lanePos) {
            const xCenter = lanePos[this.lane];
            return {
                x: xCenter - this.size / 2,
                y: this.y,
                width: this.size,
                height: this.size
            };
        }
    }


    // --- Game Logic ---

    function setupCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        playerX = getLaneCenterX(currentLane);
    }

    function getLaneCenterX(laneIndex) {
        const laneWidth = canvas.width * LANE_WIDTH_PERCENTAGE;
        return (canvas.width / 2) + (laneIndex - 1) * laneWidth;
    }

    function getLaneCenters() {
        const centers = [];
        for (let i = 0; i < NUM_LANES; i++) {
            centers.push(getLaneCenterX(i));
        }
        return centers;
    }

    function spawnObstacle() {
        const lane = Math.floor(Math.random() * NUM_LANES);
        const size = 50;
        let type = 'enemy';

        const coinRoll = Math.random();

        if (coinRoll < 0.3) { // 30% chance of an item spawn
            const itemRoll = Math.random();
            if (itemRoll < MAGNET_SPAWN_CHANCE) { 
                type = 'magnet';
            } else {
                type = 'coin';
            }
        }

        obstacles.push(new Obstacle(lane, size, type));
    }

    function checkCollision(playerBounds, obstacle) {
        const obsBounds = obstacle.getBounds(getLaneCenters());

        return playerBounds.x < obsBounds.x + obsBounds.width &&
               playerBounds.x + playerBounds.width > obsBounds.x &&
               playerBounds.y < obsBounds.y + obsBounds.height &&
               playerBounds.y + playerBounds.height > obsBounds.y;
    }

    function getPlayerBounds(x) {
        const collisionSize = PLAYER_SIZE * COLLISION_SIZE_RATIO;
        const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
        return {
            x: x - collisionSize / 2,
            y: playerCenterY - collisionSize / 2,
            width: collisionSize,
            height: collisionSize,
            centerX: x,
            centerY: playerCenterY
        };
    }

    // Function to activate the magnet power-up
    function activateMagnet(currentTime) {
        isMagnetActive = true;
        isSlowingDown = false; 
        magnetStartTime = currentTime;
        magnetDurationMS = currentMagnetDuration * 1000; // Use dynamically calculated duration
        magnetProgressContainer.classList.remove('opacity-0');
        playPowerupSound();
    }
    
    // Function to end the magnet power-up cleanly
    function deactivateMagnet() {
        isMagnetActive = false;
        isSlowingDown = false;
        magnetProgressContainer.classList.add('opacity-0');
    }

    /**
     * Function to handle coin collection (still screen-wide)
     */
    function handleCoinCollection() {
        if (!isMagnetActive) return;

        let collectedCount = 0;
        
        // Loop backwards to safely modify the array
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            
            // Collect any non-hit coin
            if (obstacle.type === 'coin' && !obstacle.isHit) {
                obstacle.isHit = true; // Mark it as hit
                
                if (magnetLevel === MAGNET_MAX_LEVEL) {
                    runCoins += 15;
                } else {
                    runCoins++;
                }

                collectedCount++;
            }
        }

        if (collectedCount > 0) {
            runCoinsValueElement.textContent = runCoins;
            // To prevent audio stuttering at high speeds, we only play it every 5th frame
            if (Math.floor(score) % 5 === 0) {
                playCoinSound(); 
            }
        }

        // Filter out collected coins (enemies and magnets remain)
        obstacles = obstacles.filter(o => o.type !== 'coin' || !o.isHit);
    }

    function drawGame(laneCenters, currentTime) {
        ctx.save();
        
        const isShaking = (gameState === 'SHAKING' && currentTime < shakeEndTime);
        if (isShaking) {
            const elapsed = shakeEndTime - currentTime;
            const progress = elapsed / SHAKE_DURATION; // Goes from 1 to 0
            const magnitude = SHAKE_MAGNITUDE * progress * progress; // Ease-out effect
            const x = (Math.random() - 0.5) * 2 * magnitude;
            const y = (Math.random() - 0.5) * 2 * magnitude;
            ctx.translate(x, y);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw lane lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 3;
        const lineOffset = (canvas.width * LANE_WIDTH_PERCENTAGE) / 2;
        ctx.beginPath();
        ctx.moveTo(getLaneCenterX(0) + lineOffset, 0);
        ctx.lineTo(getLaneCenterX(0) + lineOffset, canvas.height);
        ctx.moveTo(getLaneCenterX(2) - lineOffset, 0);
        ctx.lineTo(getLaneCenterX(2) - lineOffset, canvas.height);
        ctx.stroke();

        const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
        const playerDrawX = playerX - PLAYER_SIZE / 2;
        const playerDrawY = playerCenterY - PLAYER_SIZE / 2;

        // Draw player jet
        if (playerImg.isLoaded) {
            // If magnet is active, draw a blue glow around the player
            if (isMagnetActive) {
                const maxBlur = 30;
                let blur = 0;
                if (isSlowingDown) {
                    const timeSlowing = (magnetStartTime + magnetDurationMS) - performance.now();
                    const ratio = timeSlowing / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                    blur = Math.max(0, maxBlur * ratio); 
                } else {
                    blur = maxBlur;
                }
                
                ctx.shadowColor = '#3b82f6';
                ctx.shadowBlur = blur;
            }
            ctx.drawImage(playerImg, playerDrawX, playerDrawY, PLAYER_SIZE, PLAYER_SIZE);
            ctx.shadowColor = 'transparent'; // Reset shadow
            ctx.shadowBlur = 0;
        } else {
            // Fallback drawing if image is still loading
            ctx.fillStyle = isMagnetActive ? '#2563eb' : '#3b82f6'; 
            ctx.beginPath();
            ctx.moveTo(playerX, playerDrawY);
            ctx.lineTo(playerDrawX, playerDrawY + PLAYER_SIZE);
            ctx.lineTo(playerDrawX + PLAYER_SIZE, playerDrawY + PLAYER_SIZE);
            ctx.closePath();
            ctx.fill();
        }

        // Draw obstacles
        obstacles.forEach(obstacle => obstacle.draw(ctx, laneCenters));
        
        // When PAUSED, draw a semi-transparent dark overlay on top of the game
        if (gameState === 'PAUSED') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.restore();
    }

    // --- Game Control Functions ---
    
    function showModal(modalElement) {
        // Hide all modals
        gameModal.classList.add('hidden');
        pauseMenuModal.classList.add('hidden');
        // jetShopModal.classList.add('hidden'); // <-- REMOVED
        
        // Show the requested modal
        modalElement.classList.remove('hidden');
    }

    function pauseGame() {
        if (gameState !== 'PLAYING') return;
        
        gameState = 'PAUSED';
        showModal(pauseMenuModal);
        // The game loop will stop execution on the next frame check
    }

    function unpauseGame() {
        if (gameState !== 'PAUSED') return;
        
        gameState = 'PLAYING';
        showModal(gameModal); // Hides all modals
        gameModal.classList.add('hidden'); // Ensure no modal is visible
        
        // Crucial: Reset lastTime to current time
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function startGame() {
        // Reset state
        score = 0;
        runCoins = 0;
        baseGameSpeed = INITIAL_GAME_SPEED;
        currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
        speedLevel = 0;
        obstacles = [];
        currentLane = 1;
        targetLane = 1;
        setupCanvas();
        playerX = getLaneCenterX(currentLane);
        
        // Re-load data to ensure current magnet level and jet are used
        loadGameData(); 
        updateMagnetDuration();

        // Reset Magnet State
        deactivateMagnet();
        
        shakeEndTime = 0;

        // Hide Modals and show Pause Button
        gameModal.classList.add('hidden');
        pauseMenuModal.classList.add('hidden');
        // jetShopModal.classList.add('hidden'); // REMOVED
        pauseButton.classList.remove('hidden');
        finalScore.classList.add('hidden');
        coinsEarned.classList.add('hidden');
        scoreValueElement.textContent = '0';
        runCoinsValueElement.textContent = '0';

        gameState = 'PLAYING';
        requestAnimationFrame(gameLoop);
    }

    function finishGameOver() {
        gameState = 'GAMEOVER';

        // Save persistent coins to local storage
        saveCoins(runCoins);
        
        // Hide magnet bar and pause button
        deactivateMagnet();
        pauseButton.classList.add('hidden');

        // Show Game Over Modal
        showModal(gameModal);
        modalTitle.textContent = "FLIGHT TERMINATED";
        modalMessage.textContent = "You collided with a enemy aircraft!";
        startButton.textContent = "RETRY";

        finalScore.textContent = `FINAL SCORE: ${Math.floor(score).toLocaleString()} meters`;
        finalScore.classList.remove('hidden');

        coinsEarned.textContent = `Coins Earned: $ ${runCoins}`;
        coinsEarned.classList.remove('hidden');
    }

    function gameOver() {
        gameState = 'SHAKING';
        shakeEndTime = performance.now() + SHAKE_DURATION;
        playDeathSound();
    }

    // --- Jet Shop Logic (REMOVED) ---
    // function populateJetShop() { ... }
    // function handleJetShopClick(e) { ... }
    // --- End: Jet Shop Logic (REMOVED) ---


    // --- Game Loop ---
    function gameLoop(currentTime) {
        if (gameState === 'START' || gameState === 'GAMEOVER') {
            lastTime = currentTime;
            return;
        }
        
        if (gameState === 'PAUSED') {
             drawGame(getLaneCenters(), currentTime);
             return;
        }

        deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        const laneCenters = getLaneCenters();

        if (gameState === 'SHAKING') {
            if (currentTime > shakeEndTime) {
                finishGameOver();
                return;
            }
            
            obstacles = obstacles.filter(obstacle => {
                obstacle.update(currentEffectiveGameSpeed * 60, deltaTime);
                return obstacle.y < canvas.height;
            });
            
            drawGame(laneCenters, currentTime);
            requestAnimationFrame(gameLoop);
            return;
        }

        // --- 'PLAYING' state ---
        const playerBounds = getPlayerBounds(playerX);

        // 1. Update Base Game Speed
        const newSpeedLevel = Math.floor(score / SPEED_INCREMENT_SCORE);
        if (newSpeedLevel > speedLevel) {
            speedLevel = newSpeedLevel;
            baseGameSpeed = INITIAL_GAME_SPEED * (1 + (speedLevel * SPEED_INCREMENT_AMOUNT));
        }

        // 2. Update Effective Game Speed (Magnet Effect)
        let speedMultiplier = 1;
        
        if (isMagnetActive) {
            const timeElapsed = currentTime - magnetStartTime;
            const timeLeft = magnetDurationMS - timeElapsed;
            
            if (timeLeft <= 0) {
                deactivateMagnet();
            } else if (timeLeft <= MAGNET_SLOWDOWN_TIME_SECONDS * 1000) {
                isSlowingDown = true;
                const slowDownRatio = timeLeft / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                const speedRange = MAGNET_BOOST_MULTIPLIER - 1;
                speedMultiplier = 1 + (speedRange * Math.max(0, slowDownRatio)); 
            } else {
                speedMultiplier = MAGNET_BOOST_MULTIPLIER;
            }

            const progress = (timeLeft / magnetDurationMS) * 100;
            magnetProgressBar.style.width = `${progress}%`;

        } else {
            isSlowingDown = false;
        }
        
        currentEffectiveGameSpeed = baseGameSpeed * speedMultiplier;
        
        // 3. Score Update
        score += currentEffectiveGameSpeed * 10 * deltaTime; 

        // 4. Update Player Position
        const targetX = getLaneCenterX(targetLane);
        playerX += (targetX - playerX) * PLAYER_MOVE_SPEED;
        if (Math.abs(playerX - targetX) < 1) {
            currentLane = targetLane;
        }

        // 5. Update Obstacles
        obstacles = obstacles.filter(obstacle => {
            obstacle.update(currentEffectiveGameSpeed * 60, deltaTime);
            return obstacle.y < canvas.height;
        });

        // 6. Spawn new obstacle
        if (currentTime - lastObstacleTime > 1600 / (baseGameSpeed * 0.8)) {
            spawnObstacle();
            lastObstacleTime = currentTime;
        }

        // 7. Coin Collection Logic
        if (isMagnetActive) {
            handleCoinCollection();
        }
        
        // 8. Collision Detection
        obstacles.forEach(obstacle => {
            if (!obstacle.isHit && checkCollision(playerBounds, obstacle)) {
                obstacle.isHit = true;
                
                if (obstacle.type === 'enemy') {
                    if (!isMagnetActive) {
                        gameOver();
                    }
                } else if (obstacle.type === 'coin') {
                    if (isMagnetActive && magnetLevel === MAGNET_MAX_LEVEL) {
                        runCoins += 15;
                    } else {
                        runCoins++;
                    }
                    runCoinsValueElement.textContent = runCoins;
                    playCoinSound();
                } else if (obstacle.type === 'magnet') {
                    activateMagnet(currentTime);
                }
            }
        });

        // 9. Remove collected items
        obstacles = obstacles.filter(o => (o.type !== 'coin' && o.type !== 'magnet' && o.type !== 'enemy') || !o.isHit);

        // 10. Draw
        drawGame(laneCenters, currentTime);

        // 11. Update UI
        scoreValueElement.textContent = Math.floor(score).toLocaleString();

        requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners & Initialization ---

    // 1. Handle resize
    window.addEventListener('resize', setupCanvas);

    // 2. Start Button
    startButton.addEventListener('click', startGame);

    // 3. Pause Button & Menu Handlers
    pauseButton.addEventListener('click', pauseGame);
    resumeButton.addEventListener('click', unpauseGame);
    
    shopButton.addEventListener('click', () => {
        // This is the "Upgrades Shop", assuming it's also a separate page
        // If it was meant to be the jet shop, it should also be "shop.html"
        // For now, leaving it as 'shop.html' as that's the only shop we have.
        // If you have a different upgrades shop, change 'shop.html' to 'upgrades.html' etc.
        gameState = 'PAUSED'; 
        window.location.href = 'shop.html'; // Changed to shop.html
    }); 
    
    // --- Jet Shop Listeners (REMOVED) ---
    // jetShopMenuButton.addEventListener('click', ...);
    // jetShopBackButton.addEventListener('click', ...);
    // jetShopGrid.addEventListener('click', ...);
    // --- End: Jet Shop Listeners (REMOVED) ---

    settingsButton.addEventListener('click', () => {
        // Temporarily use the main game modal to display a message, then unpause
        gameModal.classList.remove('hidden');
        pauseMenuModal.classList.add('hidden');
        modalTitle.textContent = "SETTINGS";
        modalMessage.textContent = "Version: v1.0.0. No customizable settings yet.";
        startButton.textContent = "CONTINUE";

        const tempStartHandler = () => {
            gameModal.classList.add('hidden');
            unpauseGame(); 
            startButton.removeEventListener('click', tempStartHandler);
            startButton.addEventListener('click', startGame); 
        };
        
        startButton.removeEventListener('click', startGame);
        startButton.addEventListener('click', tempStartHandler);
    });

    // 4. Input Handling
    function handleInput(isRight) {
        if (gameState === 'PLAYING') {
            if (isRight && targetLane < NUM_LANES - 1) {
                targetLane++;
            } else if (!isRight && targetLane > 0) {
                targetLane--;
            }
        }
    }

    // Keyboard Input
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
            handleInput(true);
        } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
            handleInput(false);
        } else if (e.key === 'Enter' && gameState !== 'PLAYING') {
            if (gameState === 'PAUSED') {
                // Check which modal is open.
                if (!pauseMenuModal.classList.contains('hidden')) {
                   // In pause menu, don't unpause with Enter
                   return;
                }
                unpauseGame();
            } else if (gameState === 'GAMEOVER' || gameState === 'START') {
                startGame();
            }
        } else if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
            if (gameState === 'PLAYING') {
                pauseGame();
            } else if (gameState === 'PAUSED') {
                // If in pause menu, unpause
                if (!pauseMenuModal.classList.contains('hidden')) {
                    unpauseGame();
                }
            } 
        }
    });

    // Touch/Click Input (Mobile friendly)
    canvas.addEventListener('mousedown', (e) => {
        if (gameState !== 'PLAYING') return;
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        handleInput(x > canvas.width / 2); // True if tapped on the right half
    });

    canvas.addEventListener('touchstart', (e) => {
        if (gameState !== 'PLAYING') return;
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.touches[0].clientX - rect.left;
        handleInput(x > canvas.width / 2); // True if tapped on the right half
    });

    // Start initialization and game loop on load
    window.onload = function() {
        loadGameData(); // Load all persistent data (coins, magnet level, and jets)
        updateMagnetDuration(); // Ensure the duration is correct on startup
        setupCanvas();
        pauseButton.classList.add('hidden'); 
        requestAnimationFrame(gameLoop);
    };

</script>
</body>
</html>
