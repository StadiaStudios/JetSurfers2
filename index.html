<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-g">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JetSurfers 2</title>
    <!-- Assuming these scripts exist in the folder structure -->
    <!-- <script src="weather/snowfall_effect.js"></script> -->
    <!-- <script src="weather/rain_effect.js"></script> -->
    <!-- Mock scripts for rain/snow effects to prevent console errors if missing -->
    <script src="weather/rain_effect.js"></script>
    <script src="weather/snowfall_effect.js"></script>
    <link rel="icon" href="rec/xmas-icon.jpg" type="image/png">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="jets-data.js"></script>
    
    <style>
        /* Custom Styles for Game Canvas and UI */
        body {
            font-family: 'Inter', sans-serif;
            /* Default background, will be set by JS on load using DEFAULT_BACKGROUND constant */
            background: linear-gradient(180deg, #9b9292 0%, #887575 100%); /* Initial Red Gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
            /* Added transition for smooth background color change */
            transition: background 0.8s ease;
        }
        #gameContainer {
            width: 100%;
            max-width: 450px; /* Default for mobile/small screen */
            aspect-ratio: 9/16; /* Standard mobile aspect ratio */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0);
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(180deg, #1f2937 0%, #111827 100%); /* Darker gradient for the structure */
            position: relative;
        }

        /* Desktop specific styles for larger canvas */
        @media (min-width: 768px) {
            #gameContainer {
                max-width: 600px; /* Bigger size for desktop */
            }
        }
        
        #gameCanvas {
            display: block;
            /* Background will be set dynamically by JavaScript */
            transition: background 0.8s ease; /* Added transition for smooth background color change */
            width: 100%;
            height: 100%;
        }

        #canvasContainer {
            width: 600px; /* Match canvas width */
            height: 400px; /* Fixed height for scrollable area */
            overflow-y: scroll; /* Enable vertical scrolling */
            position: relative;
            /* Custom scrollbar styling */
            scrollbar-width: thin; /* For Firefox */
            scrollbar-color: #888 #f1f1f1; /* For Firefox */
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            /* Allows touches to pass through the UI elements to the canvas */
            pointer-events: none;
        }
        .top-bar {
            position: absolute;
            top: 15px;
            /* Use full width and let padding handle spacing */
            width: 100%;
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap on small screens */
            justify-content: space-between;
            align-items: center;
            color: #f3f4f6;
            font-weight: bold;
            font-size: 1rem;
            padding: 0 15px; /* Padding on both sides */
        }
        .top-bar > div {
            flex-shrink: 0; /* Prevent flex items from shrinking */
        }
        .score-box {
            background: #008cff;
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            min-width: 80px; /* Ensure boxes are readable */
            justify-content: flex-start; /* Align content to the left */
            margin: 2px 4px; /* Add small margin for spacing when wrapped */
        }
        .score-box.score-main {
            flex-grow: 1; /* Allow score to take up space */
            justify-content: center; /* Center the main score text */
        }
        .coin-icon {
            /* Now an image, not a star text */
            width: 18px; 
            height: 18px;
            margin-right: 6px;
            /* Added object-fit for visual consistency */
            object-fit: contain; 
        }
        .modal {
            background: #111;
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px #0988ff;
            border: 2px solid rgba(255, 0, 0, 0);
            pointer-events: auto; /* Re-enable pointer events for the modal */
            max-width: 90%; /* Allow modal to be slightly wider for shop */
            width: 400px;
            max-height: 90vh; /* Ensure modal fits on screen */
            overflow-y: auto; /* Allow scrolling if content is too tall */
            z-index: 20; /* Ensure modal is on top */
        }
        
        .game-button {
            padding: 10px 25px;
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            background-color: #f63b3b;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px red;
        }
        .game-button:hover {
            background-color: #ff0000;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px red;
        }
        
        /* NEW Style for Headstart Button */
        #useHeadstartButton {
            background-color: #f59e0b; /* Amber/Orange */
            box-shadow: 0 4px #d97706;
            margin-top: 10px;
            padding: 8px 20px;
            font-size: 0.9rem;
        }
        #useHeadstartButton:hover {
            background-color: #eab308;
        }
        #useHeadstartButton:active {
            box-shadow: 0 2px #d97706;
        }

        /* NEW Style for Repair Kit Button */
        #useRepairKitButton {
            background-color: #06b6d4; /* Cyan */
            box-shadow: 0 4px #0e7490;
            margin-top: 10px;
            padding: 8px 20px;
            font-size: 0.9rem;
        }
        #useRepairKitButton:hover {
            background-color: #0891b2;
        }
        #useRepairKitButton:active {
            box-shadow: 0 2px #0e7490;
        }


        /* --- Base Progress Bar Styles --- */
        .progress-container {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 16px;
            background-color: #111;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s;
            pointer-events: none;
            display: flex;
            align-items: center;
            padding: 0 4px;
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 6px;
        }
        .progress-icon {
            position: absolute;
            left: 8px;
            color: white;
            font-size: 0.9rem;
            z-index: 2;
        }

        /* --- Magnet Progress Bar --- */
        #magnetProgressContainer {
            top: 60px; /* Below the top score bar */
        }
        #magnetProgressBar {
            background: linear-gradient(90deg, #0468fd, #6453ff); /* Blue gradient */
        }

        /* --- NEW: Jetpack Progress Bar --- */
        #jetpackProgressContainer {
            top: 85px; /* Below magnet bar */
        }
        #jetpackProgressBar {
            background: linear-gradient(90deg, #0468fd, #6453ff); /* Orange gradient */
        }

        /* --- NEW: Repair Kit Progress Bar --- */
        #repairKitProgressContainer {
            top: 110px; /* Below the jetpack bar */
        }
        #repairKitProgressBar {
            background: linear-gradient(90deg, rgb(1, 196, 255), #ff5e59); /* Cyan gradient */
        }


        /* --- Pause Button Styles --- */
        .pause-button {
            pointer-events: auto; /* Allow clicks */
            background: #008cff;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: background-color 0.15s;
            border: none; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .pause-button img {
            width: 20px;
            height: 20px;
            display: block;
            margin: 0;
        }
        
        /* --- Menu Button Styles for Pause Modal --- */
        .menu-button {
            display: block; /* Changed from width: 100% to ensure <a> tag behaves same */
            width: 100%;
            padding: 12px 0;
            margin: 8px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f3f4f6;
            background-color: #398bff; /* Darker blue/gray */
            border: 2px solid rgb(0, 0, 0);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px #4983ff;
            text-decoration: none; /* Added for <a> tag */
            text-align: center; /* Added for <a> tag */
            position: relative; /* NEW: For notification icon */
        }

        .menu-button:hover {
            background-color: #374151;
        }

        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #111827;
        }
        
        /* NEW: Button style for Export/Import */
        .menu-button.export {
            background-color: #398bff; /* Green */
            box-shadow: 0 4px #398bff;
        }
        .menu-button.export:hover {
            background-color: #374151;
        }
        .menu-button.export:active {
            box-shadow: 0 2px rgb(118, 192, 0);
        }

        .menu-button.import {
            background-color: #398bff; /* Amber */
            box-shadow: 0 4px #398bff;
        }
        .menu-button.import:hover {
            background-color: #374151;
        }
        .menu-button.import:active {
            box-shadow: 0 2px #f06800;
        }
        
        /* NEW: Boosting Text */
        #boostingText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: yellow;
            text-shadow: 0 0 10px red, 0 0 20px red;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 50; /* Ensure it's on top */
        }
        
        /* Stat item styling (from stats.html for consistency) */
        .stat-item {
            background: #333;
            border: 2px solid #ff8e8e;
            border-radius: 8px;
            padding: 16px;
            text-align: left;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stat-label {
            font-size: 1.1rem;
            font-weight: 600;
            color: #f3f4f6;
        }
        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #fcd34d; /* Yellow for values */
        }

        /* --- Loading Screen Styles --- */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #8db1ff; /* Dark background */
            z-index: 1000; /* Highest z-index */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            transition: opacity 0.5s ease-out;
            text-align: center;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none; /* Allow clicks to pass through during fade-out */
        }

        .loading-content img {
            width: 100px;
            height: 100px;
            border-radius: 20px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
            display: block; /* Ensure it's a block element */
            margin: 0 auto 20px auto; /* Center horizontally and keep bottom margin */
        }

        .loading-content h1 {
            font-size: 2.5rem;
            font-weight: 900;
            text-shadow: 0 0 10px #398bff;
        }

        .loading-content p {
            font-size: 1.2rem;
            margin-top: 10px;
            color: #9ca3af;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(57, 139, 255, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 10px 20px rgba(57, 139, 255, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(57, 139, 255, 0); }
        }

    </style>
</head>
<body>

<!-- NEW: Offline Screen -->
<div id="offline-screen" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(17, 24, 39, 0.95); z-index: 1001; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white;">
    <svg class="w-24 h-24 text-red-500 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width: 6rem; height: 6rem; color: #ef4444;">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 5.636a9 9 0 010 12.728m-12.728 0a9 9 0 010-12.728m12.728 0L5.636 18.364m0-12.728L18.364 18.364"></path>
    </svg>
    <h2 class="text-4xl font-extrabold text-white mt-4 mb-2" style="font-size: 2.25rem; font-weight: 800; margin-top: 1rem; margin-bottom: 0.5rem;">Connection Lost</h2>
    <p class="text-xl text-gray-300" style="font-size: 1.25rem; color: #d1d5db;">Please connect to the internet to play JetSurfers 2.</p>
</div>


<div id="gameContainer">

    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay for Score and Modals -->
    <div class="ui-overlay">
        
        <!-- Pause Button (Positioned top left) -->
        <button id="pauseButton" class="pause-button absolute top-4 left-4 z-10">
            <!-- Updated to use a PNG image for better styling -->
            <img src="rec/pause_icon.png" alt="Pause" class="w-5 h-5" onerror="this.src='https://placehold.co/20x20/008cff/ffffff?text=II'">
        </button>
        
        <!-- Top Bar for Score and Coins -->
        <div class="top-bar">
            <!-- Left-aligned items -->
            <div class="flex items-center" style="margin-left: 45px;">
                <!-- Headstart Inventory Display (New) -->
                <div id="headstartInventoryBox" class="score-box" style="min-width: unset; pointer-events: auto;">
                    <img src="rec/items/headstart.png" alt="Headstart" class="coin-icon" onerror="this.src='https://placehold.co/18x18/f59e0b/ffffff?text=üöÄ'">
                    <span id="headstartCount">0</span>
                </div>
                <!-- NEW: Repair Kit Inventory Display -->
                <div id="repairKitInventoryBox" class="score-box" style="min-width: unset; pointer-events: auto; margin-left: 5px;">
                    <img src="rec/items/repairkit.png" alt="Repair Kit" class="coin-icon" onerror="this.src='https://placehold.co/18x18/06b6d4/ffffff?text=üõ°Ô∏è'">
                    <span id="repairKitCount">0</span>
                </div>
            </div>
            <!-- Center Score Display -->
            <div class="score-box score-main">
                <span id="scoreValue">0</span> m
            </div>
            <!-- Right-aligned coin items -->
            <div class="flex flex-col items-end">
                <!-- Current Run Coins -->
                <div class="score-box">
                    <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='https://placehold.co/18x18/facc15/000000?text=$'"> 
                    <span id="runCoinsValue">0</span>
                </div>
            </div>
        </div>

        <!-- Magnet Progress Bar -->
        <div id="magnetProgressContainer" class="progress-container opacity-0">
            <span id="magnetIcon" class="progress-icon">üß≤</span>
            <div id="magnetProgressBar" class="progress-bar"></div>
        </div>
        
        <!-- NEW: Jetpack Progress Bar -->
        <div id="jetpackProgressContainer" class="progress-container opacity-0">
            <span id="jetpackIcon" class="progress-icon">üî•</span>
            <div id="jetpackProgressBar" class="progress-bar"></div>
        </div>

        <!-- NEW: Repair Kit Progress Bar -->
        <div id="repairKitProgressContainer" class="progress-container opacity-0">
            <span id="repairKitIcon" class="progress-icon">üõ°Ô∏è</span>
            <div id="repairKitProgressBar" class="progress-bar"></div>
        </div>


        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <h1 id="modalTitle" class="text-3xl font-extrabold mb-4 text-[white]">JET SURFERS <p style="color:red;">II</p></h1>
            <p id="modalMessage" class="text-lg mb-6">
                Collect coins and avoid oncoming aircrafts.
            </p>
            <p class="text-sm mb-6 text-gray-300">
                Controls:<br>
                Desktop: A or Left Arrow / D or Right Arrow | Can also tap on side<br>
                Mobile: Swipe Left / Right <br>
                <b class="text-cyan-400">Double-Tap / Double-Press 'R' to use Repair Kit</b>
            </p>
            <button id="startButton" class="game-button">PLAY NOW</button>
            <button id="reviveButton" class="game-button hidden">REVIVE ($300)</button>
            <button id="useHeadstartButton" class="game-button hidden">USE HEADSTART (<span id="startHeadgetCount">0</span>)</button>            
            <div id="finalScore" class="text-xl font-bold mt-4 hidden"></div>
            <div id="coinsEarned" class="text-xl font-bold text-yellow-400 mt-2 hidden"></div>
        </div>

        <!-- Pause Menu Modal -->
        <div id="pauseMenuModal" class="modal hidden">
            <h2 class="text-3xl font-extrabold mb-8 text-white">PAUSED</h2>
            <button id="resumeButton" class="menu-button">RESUME</button>
            <button id="quitButton" class="menu-button">QUIT</button>
            <button id="shopButton" class="menu-button">UPGRADES SHOP</button>
            <!-- UPDATED: This is now a link to shop.html -->
            <a href="jetshop.html" id="jetShopMenuButton" class="menu-button">JET SHOP</a>
            <!-- NEW: Link to quests.html -->
            <a href="quests.html" id="questsMenuButton" class="menu-button">
                DAILY CHALLENGES
                <!-- NEW: Quest Notification Icon -->
                <img src="rec/exclamation.png" id="questNotificationIcon" class="hidden absolute top-0 right-0 w-10 h-10 -mt-2 -mr-2" alt="!" 
                     onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSIjRkRFNCA0NyI+PGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTEgMTVIMTNWMTdIMTF6TTExIDdIMTNWMTNIMTF6Ii8+PC9zdmc+'; this.onerror=null;">
            </a>
            <button id="settingsButton" class="menu-button">SETTINGS</button>
            <p class="text-xs text-gray-500 mt-6">Game Version: v1.5.4</p>
        </div>
        
        <!-- NEW: Settings Menu Modal -->
        <div id="settingsModal" class="modal hidden">
            <h2 class="text-3xl font-extrabold mb-8 text-white">SETTINGS</h2>

            <!-- High Score Display -->
            <div class="stat-item">
                <span class="stat-label">High Score</span>
                <span id="settingsHighScoreValue" class="stat-value">0 m</span>
            </div>

            <!-- NEW: Jets Owned Display -->
            <div class="stat-item">
                <span class="stat-label">Jets Owned</span>
                <span id="settingsJetsOwnedValue" class="stat-value">0/0</span>
            </div>

            <!-- NEW: What's New Button -->
            <a href="changelog.txt" class="menu-button mt-4">WHAT'S NEW</a>

            <!-- NEW: Export/Import Buttons -->
            <button id="exportSaveButton" class="menu-button export mt-4">EXPORT SAVE</button>
            <button id="importSaveButton" class="menu-button import">IMPORT SAVE</button>
            <input type="file" id="importFileInput" accept=".json" class="hidden">
            <!-- NEW: Feedback message for import -->
            <p id="importStatusMessage" class="text-sm text-yellow-400 mt-2 hidden"></p>
            <!-- END: Export/Import Buttons -->

            <!-- Game Version Display -->
            <div class="text-center text-gray-400 mt-6">
                <p>Game Version: v1.5.4</p>
            </div>

            <button id="settingsBackButton" class="menu-button mt-8">BACK</button>
        </div>

        <!-- NEW: Boosting Text Overlay -->
        <div id="boostingText" class="hidden">BOOSTING</div>

    </div>
</div>

<!-- NEW: Loading Screen -->
<div id="loadingScreen">
    <div class="loading-content">
        <!-- Using the same icon as the favicon for consistency -->
        <img src="rec/xmas-icon.jpg" alt="JetSurfers Logo" onerror="this.style.display='none'">
        <h1>JetSurfers</h1>
    </div>
</div>

<script>
    // Start initialization and game loop on load
    window.onload = function() {
        // --- NEW: Offline Detection ---
        function handleConnectionChange() {
            const offlineScreen = document.getElementById('offline-screen');
            const gameContainer = document.getElementById('gameContainer');
            const loadingScreen = document.getElementById('loadingScreen');

            if (navigator.onLine) {
                // We are online
                offlineScreen.style.display = 'none';
                gameContainer.style.display = 'block';
                loadingScreen.style.display = 'flex'; // Show loading screen if it was hidden
                // Refresh data in case we came back online
                loadGameData();
                checkQuestCompletion();
            } else {
                // We are offline
                offlineScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
                loadingScreen.style.display = 'none'; // Hide loading screen if offline
            }
        }

        window.addEventListener('online', handleConnectionChange);
        window.addEventListener('offline', handleConnectionChange);
        // === NEW: First Visit Loading Screen Logic ===
        const VISITED_KEY = 'jetSurfersVisited';
        // === Jets data and storage keys are now loaded from jets-data.js ===

        // --- NEW: All storage keys for backup/restore ---
        // Make sure to define REPAIR_KIT_COUNT_KEY if it's not in jets-data.js
        const REPAIR_KIT_COUNT_KEY = 'jetSurferRepairKitCount'; // DEFINED HERE
        const JETPACK_LEVEL_KEY = 'jetSurferJetpackLevel'; // NEW KEY

        const ALL_STORAGE_KEYS = [
            COIN_STORAGE_KEY, MAGNET_LEVEL_KEY, JET_OWNED_KEY, 
            JET_SELECTED_KEY, HEADSTART_COUNT_KEY, COIN_MULTIPLIER_LEVEL_KEY,
            HIGH_SCORE_KEY, MONEY_SPENT_KEY, QUEST_STORAGE_KEY,
            REPAIR_KIT_COUNT_KEY, JETPACK_LEVEL_KEY // Added new keys
        ];

        let ownedJets = [DEFAULT_JET_ID];
        let selectedJetId = DEFAULT_JET_ID;
        // --- END: Jet Definitions ---

        let totalCoins = 0; // The persistent total
        let magnetLevel = 0; // The persistent magnet level (0 to 5)
        let headstartCount = 0; // The persistent headstart item count
        let repairKitCount = 0; // NEW: The persistent repair kit item count
        let coinMultiplierLevel = 0; // The persistent multiplier level
        let jetpackLevel = 0; // NEW: The persistent jetpack level

        function loadGameData() {
            // Handle potential parsing errors
            try {
                const storedCoins = localStorage.getItem(COIN_STORAGE_KEY);
                // NEW: Check for first-time load
                if (storedCoins === null) {
                    // It's the first time, give the player 150 coins as a welcome bonus
                    totalCoins = 150;
                    localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
                } else {
                    // Not the first time, load existing coins
                    totalCoins = parseInt(storedCoins, 10) || 0;
                }
                const storedMagnetLevel = localStorage.getItem(MAGNET_LEVEL_KEY);
                magnetLevel = storedMagnetLevel ? parseInt(storedMagnetLevel, 10) : 0;
                
                const storedHeadstartCount = localStorage.getItem(HEADSTART_COUNT_KEY);
                headstartCount = storedHeadstartCount ? parseInt(storedHeadstartCount, 10) : 0;

                // NEW: Load Repair Kit Count
                const storedRepairKitCount = localStorage.getItem(REPAIR_KIT_COUNT_KEY);
                repairKitCount = storedRepairKitCount ? parseInt(storedRepairKitCount, 10) : 0;
                
                const storedCoinMultiplierLevel = localStorage.getItem(COIN_MULTIPLIER_LEVEL_KEY);
                coinMultiplierLevel = storedCoinMultiplierLevel ? parseInt(storedCoinMultiplierLevel, 10) : 0;

                // NEW: Load Jetpack Level
                const storedJetpackLevel = localStorage.getItem(JETPACK_LEVEL_KEY);
                jetpackLevel = storedJetpackLevel ? parseInt(storedJetpackLevel, 10) : 0;

                // --- Load Jet Data ---
                const storedOwnedJets = localStorage.getItem(JET_OWNED_KEY);
                ownedJets = storedOwnedJets ? JSON.parse(storedOwnedJets) : [DEFAULT_JET_ID];

                const storedSelectedJet = localStorage.getItem(JET_SELECTED_KEY);
                selectedJetId = storedSelectedJet ? storedSelectedJet : DEFAULT_JET_ID;

            } catch (e) {
                console.error("Error loading game data, resetting to defaults:", e);
                // Reset to defaults if data is corrupt
                totalCoins = 150;
                magnetLevel = 0;
                headstartCount = 0;
                repairKitCount = 0;
                coinMultiplierLevel = 0;
                jetpackLevel = 0; // NEW
                ownedJets = [DEFAULT_JET_ID];
                selectedJetId = DEFAULT_JET_ID;
                // Clear potentially corrupt keys
                ALL_STORAGE_KEYS.forEach(key => localStorage.removeItem(key));
                // Save fresh default data
                localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
                localStorage.setItem(JET_OWNED_KEY, JSON.stringify(ownedJets));
                localStorage.setItem(JET_SELECTED_KEY, selectedJetId);
            }

            // Update UI
            document.getElementById('headstartCount').textContent = headstartCount.toLocaleString();
            document.getElementById('repairKitCount').textContent = repairKitCount.toLocaleString(); // NEW
            
            // Apply the selected jet image
            const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
            playerImg.src = selectedJet.img;
            
            // Show/Hide Headstart button on start screen
            const headstartButton = document.getElementById('useHeadstartButton');
            document.getElementById('startHeadgetCount').textContent = headstartCount;
            if (headstartCount > 0) {
                headstartButton.classList.remove('hidden');
            } else {
                headstartButton.classList.add('hidden');
            }
        }

        function saveCoins(coinsEarned) {
            if (coinsEarned > 0) {
                totalCoins += coinsEarned;
            }
            localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
        }
        
        // --- Headstart Inventory Management ---
        function spendHeadstart() {
            if (headstartCount > 0) {
                headstartCount--;
                localStorage.setItem(HEADSTART_COUNT_KEY, headstartCount);
                document.getElementById('headstartCount').textContent = headstartCount;
                // Hide the button on the modal if no more are left
                document.getElementById('startHeadgetCount').textContent = headstartCount;
                if (headstartCount === 0) {
                    document.getElementById('useHeadstartButton').classList.add('hidden');
                }
                return true;
            }
            return false;
        }
        // --- End Headstart Inventory Management ---

        // --- NEW: Repair Kit Inventory Management ---
        function spendRepairKit() {
            if (repairKitCount > 0) {
                repairKitCount--;
                localStorage.setItem(REPAIR_KIT_COUNT_KEY, repairKitCount);
                document.getElementById('repairKitCount').textContent = repairKitCount; // Update UI
                return true;
            }
            return false;
        }
        // --- End Repair Kit Inventory Management ---

        // --- Jet/Coin Functions (Still needed for loading) ---
        function spendCoins(amount) {
            if (totalCoins >= amount) {
                totalCoins -= amount;
                localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
                return true; // Purchase successful
            }
            return false; // Not enough coins
        }

        function saveOwnedJets() {
            localStorage.setItem(JET_OWNED_KEY, JSON.stringify(ownedJets));
        }

        function saveSelectedJet() {
            localStorage.setItem(JET_SELECTED_KEY, selectedJetId);
            // Also update the playerImg.src immediately
            const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
            playerImg.src = selectedJet.img;
            playerImg.isLoaded = false; // Force reload
            playerImg.onload = () => { playerImg.isLoaded = true; };
        }
        // --- End: Jet/Coin Functions ---

        function saveMagnetLevel(newLevel) {
            magnetLevel = newLevel;
            localStorage.setItem(MAGNET_LEVEL_KEY, newLevel);
            updateMagnetDuration(); // Recalculate duration when level changes
        }

        // --- NEW: Quest Notification Check ---
        function checkQuestCompletion() {
            const notificationIcon = document.getElementById('questNotificationIcon');
            if (!notificationIcon) return; // Exit if element not found

            const today = getTodayDateString();
            const storedQuests = localStorage.getItem(QUEST_STORAGE_KEY);
            let showNotification = false;

            if (storedQuests) {
                try {
                    const questData = JSON.parse(storedQuests);
                    // Only check if quests are for today
                    if (questData.lastRefreshed === today) {
                        // Check if any quest is complete but not claimed
                        showNotification = questData.quests.some(quest => quest.isComplete && !quest.isClaimed);
                    }
                } catch (e) {
                    console.error("Failed to check quest completion:", e);
                    showNotification = false;
                }
            }

            if (showNotification) {
                notificationIcon.classList.remove('hidden');
            } else {
                notificationIcon.classList.add('hidden');
            }
        }
        // --- End Quest Notification Check ---

        // --- NEW: Quest Progress Logic ---
        function getTodayDateString() {
            const now = new Date();
            return now.toISOString().split('T')[0]; // YYYY-MM-DD
        }

        function updateQuestProgress(type, amount) {
            const today = getTodayDateString();
            const storedQuests = localStorage.getItem(QUEST_STORAGE_KEY);
            
            if (!storedQuests) return; // No quests to update

            try {
                let questData = JSON.parse(storedQuests);

                // If quests are old, don't update progress
                if (questData.lastRefreshed !== today) {
                    return;
                }

                let questsUpdated = false;
                questData.quests.forEach(quest => {
                    if (quest.isClaimed || quest.isComplete) return; // Don't update completed or claimed quests

                    let progressMade = false;
                    if (quest.id === 'score_run' && type === 'score_run') {
                        quest.progress = Math.max(quest.progress, amount);
                        progressMade = true;
                    } else if (quest.id === 'coins_run' && type === 'coins_run') {
                        quest.progress = Math.max(quest.progress, amount);
                        progressMade = true;
                    } else if (quest.id === 'games_played' && type === 'play_game') {
                        quest.progress += amount;
                        progressMade = true;
                    } else if (quest.id === 'total_coins' && type === 'total_coins') {
                        quest.progress += amount;
                        progressMade = true;
                    } else if (quest.id === 'total_meters' && type === 'total_meters') {
                        quest.progress += amount;
                        progressMade = true;
                    }

                    if (progressMade) {
                        // Check for completion
                        if (quest.progress >= quest.target) {
                            quest.progress = quest.target; // Cap progress at target
                            quest.isComplete = true;
                        }
                        questsUpdated = true;
                    }
                });

                if (questsUpdated) {
                    localStorage.setItem(QUEST_STORAGE_KEY, JSON.stringify(questData));
                    checkQuestCompletion(); // NEW: Update notification status
                }
            } catch (e) {
                console.error("Failed to update quest progress:", e);
            }
        }
        // --- End Quest Logic ---


        // --- Canvas Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        const rainEffect = new RainEffect(canvas); // Initialize rain effect

        // UI Elements
        const scoreValueElement = document.getElementById('scoreValue');
        const runCoinsValueElement = document.getElementById('runCoinsValue');
        const gameModal = document.getElementById('gameModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const startButton = document.getElementById('startButton');
        const finalScore = document.getElementById('finalScore');
        const coinsEarned = document.getElementById('coinsEarned');
        const useHeadstartButton = document.getElementById('useHeadstartButton');    
        const reviveButton = document.getElementById('reviveButton'); // NEW: Revive button
        const boostingText = document.getElementById('boostingText');

        // UI Elements for Pause Menu
        const pauseButton = document.getElementById('pauseButton');
        const pauseMenuModal = document.getElementById('pauseMenuModal');
        const resumeButton = document.getElementById('resumeButton');
        const shopButton = document.getElementById('shopButton');
        const settingsButton = document.getElementById('settingsButton');
        const settingsModal = document.getElementById('settingsModal'); // NEW
        const settingsBackButton = document.getElementById('settingsBackButton'); // NEW
        const quitButton = document.getElementById('quitButton');
        const settingsHighScoreValue = document.getElementById('settingsHighScoreValue'); // NEW
        
        // --- NEW: Settings Export/Import Elements ---
        const exportSaveButton = document.getElementById('exportSaveButton');
        const importSaveButton = document.getElementById('importSaveButton');
        const importFileInput = document.getElementById('importFileInput');
        const importStatusMessage = document.getElementById('importStatusMessage');


        // NEW UI ELEMENTS for Magnet
        const magnetProgressContainer = document.getElementById('magnetProgressContainer');
        const magnetProgressBar = document.getElementById('magnetProgressBar');

        // NEW UI ELEMENTS for Repair Kit
        const repairKitProgressContainer = document.getElementById('repairKitProgressContainer');
        const repairKitProgressBar = document.getElementById('repairKitProgressBar');

        // NEW UI ELEMENTS for Jetpack
        const jetpackProgressContainer = document.getElementById('jetpackProgressContainer');
        const jetpackProgressBar = document.getElementById('jetpackProgressBar');

        // Game Constants
        const NUM_LANES = 3;
        const LANE_WIDTH_PERCENTAGE = 0.25;
        const PLAYER_SIZE = 60;
        const COLLISION_SIZE_RATIO = 0.7;
        const PLAYER_Y_POS_RATIO = 0.8;
        const PLAYER_MOVE_SPEED = 0.15;
        const INITIAL_GAME_SPEED = 4;
        const SPEED_INCREMENT_SCORE = 1000;
        const SPEED_INCREMENT_AMOUNT = 0.02;
        
        // Headstart Constants (NEW)
        const HEADSTART_SCORE = 50000;
        const HEADSTART_DURATION_SECONDS = 10;
        const HEADSTART_SPEED_MULTIPLIER = 5;
        
        // Magnet State Variables and Constants
        const MAGNET_DURATION_SECONDS_BASE = 10; // Base duration
        const MAGNET_DURATION_BONUS_PER_LEVEL = 2; // +2 seconds per level
        const MAGNET_MAX_LEVEL = 5;
        
        let currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE; // Actual duration used in game
        
        // --- FIX: Set magnet boost to 1 (no boost) and slowdown to 0 ---
        const MAGNET_BOOST_MULTIPLIER = 1; // 3.5;
        const MAGNET_SLOWDOWN_TIME_SECONDS = 0; // 2; 
        const MAGNET_SPAWN_CHANCE = 0.05; 

        // NEW: Jetpack State Variables and Constants
        const JETPACK_DURATION_SECONDS_BASE = 8; // Base duration
        const JETPACK_DURATION_BONUS_PER_LEVEL = 2; // +2 seconds per level
        const JETPACK_MAX_LEVEL = 5;
        const JETPACK_SPAWN_CHANCE = 0.04; // Rarer than magnet
        let currentJetpackDuration = JETPACK_DURATION_SECONDS_BASE; // Actual duration
        
        // NEW: Repair Kit Constants
        const REPAIR_KIT_DURATION_SECONDS = 30;

        // Dynamic Magnet Duration Calculation
        function updateMagnetDuration() {
            currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE + (magnetLevel * MAGNET_DURATION_BONUS_PER_LEVEL);
        }
        
        // NEW: Dynamic Jetpack Duration Calculation
        function updateJetpackDuration() {
            currentJetpackDuration = JETPACK_DURATION_SECONDS_BASE + (jetpackLevel * JETPACK_DURATION_BONUS_PER_LEVEL);
        }
        
        // Initial calculation (must be called after loading magnetLevel)
        updateMagnetDuration(); 
        updateJetpackDuration(); // NEW


        // State variables
        // Added 'BOOSTING' state
        let gameState = 'START'; // Possible states: 'START', 'PLAYING', 'PAUSED', 'SHAKING', 'GAMEOVER', 'BOOSTING'
        let score = 0;
        let runCoins = 0;
        let baseGameSpeed = INITIAL_GAME_SPEED;
        let currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
        let lastTime = 0;
        let deltaTime = 0;
        let lastObstacleTime = 0;
        let currentLane = 1;
        let targetLane = 1;
        let playerX = 0;
        let obstacles = [];
        let speedLevel = 0;

        let isMagnetActive = false;
        let magnetDurationMS = 0; // duration in milliseconds, set on activation
        let magnetStartTime = 0;
        let isSlowingDown = false;
        
        // NEW: Repair Kit State
        let isRepairKitActive = false;
        let repairKitEndTime = 0;
        let repairKitCooldownEndTime = 0; // NEW: Cooldown timer
        
        // NEW: Jetpack State
        let isJetpackActive = false;
        let jetpackDurationMS = 0; 
        let jetpackCooldownEndTime = 0; // NEW: Cooldown for jetpack spawn
        
        // NEW: Double-tap/press state
        let lastTapTime = 0;
        let lastKeypressTime = 0;
        const DOUBLE_PRESS_THRESHOLD = 300; // 300ms
        
        let shakeEndTime = 0;
        let reviveInvincibilityEndTime = 0; // NEW: For post-revive invincibility
        const SHAKE_MAGNITUDE = 10;
        const SHAKE_DURATION = 300;
        
        // NEW: Revive cost constants
        const INITIAL_REVIVE_COST = 300;
        let currentReviveCost = INITIAL_REVIVE_COST;

        let boostEndTime = 0; // NEW: Headstart/Jetpack tracking

        // --- Background Styles (Updated for Red Theme) ---
        let explosions = []; // NEW: Array to hold explosion particles

        // --- NEW: Explosion Particle Class ---
        class ExplosionParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 8 + 4; // Particle size
                // Random velocity for a spray effect
                this.vx = (Math.random() - 0.5) * 12;
                this.vy = (Math.random() - 0.5) * 12;
                this.alpha = 1; // Lifespan
                // Random color between orange, yellow, and red
                const colors = ['yellow', 'orange', 'yellow', 'orange'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.04; // Fade out
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        // Default background (Red)
        const DEFAULT_BACKGROUND = 'linear-gradient(315deg, #1b2845 0%, #000f89 98%)'; 
        // Darker, stormy, spaceous red gradient
        const RAIN_BACKGROUND = 'linear-gradient(315deg, #003366 0%, #242124 74%)'; 

        // --- Canvas Background Styles (NEW) ---
        const SNOW_CANVAS_BACKGROUND = 'linear-gradient(315deg, #1b2845 0%, #000f89 74%)'; /* Light Blue Sky Gradient */
        const DARK_CANVAS_BACKGROUND = 'linear-gradient(315deg, #003366 0%, #242124 74%)'; 
        
        // --- Rain State Variables ---
        let rainTimer = 0;
        let isRaining = false;
        const RAIN_CYCLE_DURATION_MS = 120 * 1000; // 120 seconds

        // Player/Coin Images
        const playerImg = new Image();
        // playerImg.src is set by loadGameData()
        playerImg.isLoaded = false;
        playerImg.onload = () => { playerImg.isLoaded = true; };
        playerImg.onerror = () => { 
            console.error("Failed to load selected jet image. Loading default.");
            playerImg.src = 'rec/motor/default.png'; // Fallback
            playerImg.isLoaded = false; // Re-trigger onload
            playerImg.onload = () => { playerImg.isLoaded = true; };
        };

        const coinImg = new Image();
        coinImg.src = "rec/items/coin.png"; 
        coinImg.isLoaded = false;
        coinImg.onload = () => { coinImg.isLoaded = true; };
        coinImg.onerror = () => { 
            console.error("Failed to load coin image."); 
            coinImg.src = 'https://placehold.co/50x50/facc15/000000?text=$'; // Fallback
            coinImg.isLoaded = false;
            coinImg.onload = () => { coinImg.isLoaded = true; };
        };
        
        const magnetImg = new Image();
        magnetImg.src = "rec/collectible/magnet.png"; 
        magnetImg.isLoaded = false;
        magnetImg.onload = () => { magnetImg.isLoaded = true; };
        magnetImg.onerror = () => { 
            console.error("Failed to load magnet image. Using fallback."); 
            magnetImg.src = 'https://placehold.co/50x50/9333ea/ffffff?text=M'; // Fallback
            magnetImg.isLoaded = false;
            magnetImg.onload = () => { magnetImg.isLoaded = true; };
        };

        // NEW: Jetpack Image
        const jetpackImg = new Image();
        jetpackImg.src = "rec/collectible/jetpack.png"; 
        jetpackImg.isLoaded = false;
        jetpackImg.onload = () => { jetpackImg.isLoaded = true; };
        jetpackImg.onerror = () => { 
            console.error("Failed to load jetpack image. Using fallback."); 
            jetpackImg.src = 'https://placehold.co/50x50/f97316/ffffff?text=üî•'; // Fallback
            jetpackImg.isLoaded = false;
            jetpackImg.onload = () => { jetpackImg.isLoaded = true; };
        };

        // --- Audio Setup ---
        // Mock Audio objects to prevent crashes if files are missing
        const coinSound = new Audio('sfx/coin.mp3');
        const deathSound = new Audio('sfx/dead.mp3');
        const powerupSound = new Audio('sfx/powerup.mp3'); 
        const rainSound = new Audio('sfx/ambience/rain.mp3');
        const boostSound = new Audio('sfx/boost.mp3');
        const backgroundMusic = new Audio('sfx/ambience/wind.mp3');
        

        coinSound.volume = 0.6; 
        deathSound.volume = 1.0;
        powerupSound.volume = 0.6;
        rainSound.loop = true;
        rainSound.volume = 1.0; // Set rain volume to be ambient
        backgroundMusic.loop = true;
        backgroundMusic.volume = 1.0; // Lower volume so it's not overpowering
        boostSound.volume = 1.0;
        boostSound.loop = false; // FIX: Set boost sound loop to false

        let audioInitialized = false;

        function initAudio() {
            if (audioInitialized) return;

            const allSounds = [coinSound, deathSound, powerupSound, rainSound, boostSound, backgroundMusic];
            
            // Try to play and pause all sounds to unlock them.
            // This must be called from a user interaction (like the start button).
            let unlockPromises = allSounds.map(sound => {
                sound.volume = 0; // Mute them
                let promise = sound.play();
                if (promise !== undefined) {
                    return promise.then(() => {
                        sound.pause();
                        sound.currentTime = 0;
                        // Restore original volume
                        if (sound === coinSound || sound === powerupSound) sound.volume = 0.6;
                        if (sound === deathSound || sound === rainSound || sound === backgroundMusic || sound === boostSound) sound.volume = 1.0;
                    }).catch(e => {
                        // This can fail, it's okay.
                    });
                }
                return Promise.resolve();
            });

            Promise.all(unlockPromises).then(() => {
                audioInitialized = true;
                console.log("Audio unlocked");
                // Restore volumes just in case
                coinSound.volume = 0.6; 
                deathSound.volume = 1.0;
                powerupSound.volume = 0.6;
                rainSound.volume = 1.0;
                backgroundMusic.volume = 1.0;
                boostSound.volume = 1.0;
            }).catch(e => {
                console.error("Audio unlock failed (this is common):", e);
                // Still set volumes
                coinSound.volume = 0.6; 
                deathSound.volume = 1.0;
                powerupSound.volume = 0.6;
                rainSound.volume = 1.0;
                backgroundMusic.volume = 1.0;
                boostSound.volume = 1.0;
            });
        }


        function playCoinSound() {
            coinSound.currentTime = 0; 
            coinSound.play().catch(e => { /* Mute error: Audio playback failed */ });
        }

        function playDeathSound() {
            deathSound.currentTime = 0; 
            deathSound.play().catch(e => { /* Mute error: Audio playback failed */ });
        }

        function playPowerupSound() {
            powerupSound.currentTime = 0;
            powerupSound.play().catch(e => { /* Mute error: Audio playback failed */ });
        }

        function playRainSound() {
            rainSound.play().catch(e => { /* Mute error: Audio playback failed */ });
        }
        
        function stopRainSound() {
            rainSound.pause();
            rainSound.currentTime = 0;
        }
        
        function playBoostSound() {
            boostSound.currentTime = 0;
            boostSound.play().catch(e => { /* Mute error: Audio playback failed */ });
        }
        
        function stopBoostSound() {
            boostSound.pause();
            boostSound.currentTime = 0;
        }
        
        function playBackgroundMusic() {
            // Only play if the game is active
            if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                backgroundMusic.play().catch(e => { /* Mute error: Audio playback failed */ });
            }
        }
        function stopBackgroundMusic() {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }


        // --- Object Classes (Unchanged) ---

        class Obstacle {
            constructor(lane, size, type = 'enemy') {
                this.lane = lane;
                this.size = size;
                this.y = -size;
                this.type = type;
                this.isHit = false;
                this.x = null; // NEW: Add x property for non-lane-based movement
            }

            // --- FIX: Updated 'update' method to handle magnet pull ---
            update(speed, dt, isMagnetActive, playerBounds) {
                // Get current x position
                let currentX = (this.x !== null) ? this.x : getLaneCenterX(this.lane);

                if (isMagnetActive && this.type === 'coin') {
                    // --- NEW: Magnet Pull Logic ---
                    const magnetSpeed = 500; // Pixels per second
                    
                    // Calculate vector towards player's center
                    let dx = playerBounds.centerX - currentX;
                    let dy = playerBounds.centerY - (this.y + this.size / 2);
                    
                    // Normalize the vector
                    const distance = Math.sqrt(dx * dx + dy * dy) + 0.001; // Epsilon to avoid divide by zero
                    dx /= distance;
                    dy /= distance;

                    // Move towards player
                    this.y += (dy * magnetSpeed * dt);
                    this.x = currentX + (dx * magnetSpeed * dt); // Update this.x directly
                    
                    // Also apply base game speed downwards
                    this.y += speed * dt;

                } else {
                    // Default behavior
                    this.y += speed * dt;
                    // Note: If magnet stops, coin will continue falling from its last 'this.x' position
                }
            }

            // --- FIX: Updated 'draw' method to use 'this.x' if available ---
            draw(ctx, lanePos) {
                const xCenter = (this.x !== null) ? this.x : lanePos[this.lane];
                const y = this.y;

                if (this.type === 'enemy') {
                    // --- NEW: Add red glow effect ---
                    ctx.save();
                    ctx.shadowColor = 'red';
                    ctx.shadowBlur = 15;

                    // Enemy Plane (Red/Black)
                    ctx.fillStyle = this.isHit ? 'rgba(255, 0, 0, 0.8)' : 'rgba(239, 68, 68, 0.9)';
                    ctx.beginPath();
                    // Simple delta wing shape
                    ctx.moveTo(xCenter, y);
                    ctx.lineTo(xCenter - this.size / 2, y + this.size);
                    ctx.lineTo(xCenter + this.size / 2, y + this.size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Cockpit
                    ctx.fillRect(xCenter - this.size * 0.1, y + this.size * 0.2, this.size * 0.2, this.size * 0.5); // Cockpit
                    ctx.restore();
                } else if (this.type === 'coin') {
                    // Coin
                    // --- NEW: Add gold glow effect ---
                    ctx.save(); // Save current context state
                    ctx.shadowColor = 'white'; // Gold color
                    ctx.shadowBlur = 15; // The blur radius for the glow

                    if (coinImg.isLoaded) {
                        ctx.drawImage(coinImg, xCenter - this.size / 2, y, this.size, this.size);
                    } else {
                        ctx.fillStyle = '#FFEB3B';
                        ctx.beginPath();
                        ctx.arc(xCenter, y + this.size / 2, this.size * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore(); // Restore context to remove shadow for other objects
                } else if (this.type === 'magnet') {
                     // Magnet Power-up
                    ctx.save();
                    ctx.shadowColor = 'orange'; // Purple glow
                    ctx.shadowBlur = 15;

                    if (magnetImg.isLoaded) {
                        // Draw image if loaded
                        ctx.drawImage(magnetImg, xCenter - this.size / 2, y, this.size, this.size);
                    } else {
                        // Fallback to a purple square with an icon
                        ctx.fillStyle = '#9333ea'; // Deep Purple
                        ctx.fillRect(xCenter - this.size / 2, y, this.size, this.size);
                        ctx.fillStyle = 'white';
                        ctx.font = `${this.size * 0.6}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üß≤', xCenter, y + this.size / 2 + 2);
                    }
                    ctx.restore();
                } else if (this.type === 'jetpack') { // NEW: Draw Jetpack
                     // Jetpack Power-up
                    ctx.save();
                    ctx.shadowColor = 'gold'; // Orange glow
                    ctx.shadowBlur = 15;

                    if (jetpackImg.isLoaded) {
                        // Draw image if loaded
                        ctx.drawImage(jetpackImg, xCenter - this.size / 2, y, this.size, this.size);
                    } else {
                        // Fallback to an orange square with an icon
                        ctx.fillStyle = '#f97316'; // Orange
                        ctx.fillRect(xCenter - this.size / 2, y, this.size, this.size);
                        ctx.fillStyle = 'white';
                        ctx.font = `${this.size * 0.6}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üî•', xCenter, y + this.size / 2 + 2);
                    }
                    ctx.restore();
                }
            }

            // --- FIX: Updated 'getBounds' method to use 'this.x' if available ---
            getBounds(lanePos) {
                const xCenter = (this.x !== null) ? this.x : lanePos[this.lane];
                return {
                    x: xCenter - this.size / 2,
                    y: this.y,
                    width: this.size,
                    height: this.size
                };
            }
        }

        // --- NEW: Function to create explosion particles ---
        function createExplosion(x, y, count = 40) {
            // Clear any previous explosion particles
            explosions = [];
            for (let i = 0; i < count; i++) {
                explosions.push(new ExplosionParticle(x, y));
            }
        }

        // --- NEW: Coin Pattern Definitions ---
        const COIN_PATTERNS = [
            // Straight line of 5
            (lane) => [
                { lane, yOffset: 0 }, { lane, yOffset: -60 }, { lane, yOffset: -120 }, { lane, yOffset: -180 }, { lane, yOffset: -240 }
            ],
            // Straight line of 8
            (lane) => [
                { lane, yOffset: 0 }, { lane, yOffset: -60 }, { lane, yOffset: -120 }, { lane, yOffset: -180 }, 
                { lane, yOffset: -240 }, { lane, yOffset: -300 }, { lane, yOffset: -360 }, { lane, yOffset: -420 }
            ],
            // Simple diagonal
            (startLane) => {
                if (startLane === 1) return [{ lane: 1, yOffset: 0 }, { lane: 0, yOffset: -80 }, { lane: 1, yOffset: -160 }, { lane: 2, yOffset: -240 }];
                const endLane = (startLane === 0) ? 2 : 0;
                return [{ lane: startLane, yOffset: 0 }, { lane: 1, yOffset: -80 }, { lane: endLane, yOffset: -160 }];
            },
            // V-shape
            () => [
                { lane: 0, yOffset: 0 }, { lane: 1, yOffset: -80 }, { lane: 2, yOffset: 0 }
            ],
            // Full row
            () => [
                { lane: 0, yOffset: 0 }, { lane: 1, yOffset: 0 }, { lane: 2, yOffset: 0 }
            ]
        ];
        const COIN_PATTERN_CHANCE = 0.4; // 40% chance to spawn a pattern instead of a single coin


        // --- Game Logic ---

        function setupCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            playerX = getLaneCenterX(currentLane);
            
            // Update rain effect canvas reference and re-init particles for new size
            rainEffect.canvas = canvas;
            if (isRaining) {
                rainEffect.init();
            }
        }

        function getLaneCenterX(laneIndex) {
            const laneWidth = canvas.width * LANE_WIDTH_PERCENTAGE;
            return (canvas.width / 2) + (laneIndex - 1) * laneWidth;
        }

        function getLaneCenters() {
            const centers = [];
            for (let i = 0; i < NUM_LANES; i++) {
                centers.push(getLaneCenterX(i));
            }
            return centers;
        }

        function spawnObstacle() {
            // Do not spawn enemies/magnets/jetpacks during a Boost
            if (gameState === 'BOOSTING') {
                // Only allow coins to spawn during boost
                const lane = Math.floor(Math.random() * NUM_LANES);
                const size = 50;
                const type = 'coin';
                obstacles.push(new Obstacle(lane, size, type));
                return;
            }
            
            const lane = Math.floor(Math.random() * NUM_LANES);
            const size = 50;
            let type = 'enemy';

            const coinRoll = Math.random();
            const currentTime = performance.now(); // Get current time for cooldown check

            if (coinRoll < 0.3) { // 30% chance of an item spawn
                const itemRoll = Math.random();
                // Only spawn a power-up if one isn't already active
                if (itemRoll < JETPACK_SPAWN_CHANCE && !isJetpackActive && currentTime > jetpackCooldownEndTime) { // NEW: Check cooldown & allow spawn during magnet
                    type = 'jetpack';
                } else if (itemRoll < (JETPACK_SPAWN_CHANCE + MAGNET_SPAWN_CHANCE) && !isMagnetActive && !isJetpackActive) { 
                    type = 'magnet';
                } else {
                    // --- NEW: Coin Pattern Logic ---
                    if (Math.random() < COIN_PATTERN_CHANCE) {
                        // Spawn a pattern
                        const patternFn = COIN_PATTERNS[Math.floor(Math.random() * COIN_PATTERNS.length)];
                        const pattern = patternFn(lane); // Pass the random lane as a potential start
                        
                        pattern.forEach(coinInfo => {
                            const coinObstacle = new Obstacle(coinInfo.lane, size, 'coin');
                            coinObstacle.y += coinInfo.yOffset; // Apply the vertical offset
                            obstacles.push(coinObstacle);
                        });
                        return; // Exit after spawning pattern
                    } else {
                        // Spawn a single coin
                        type = 'coin';
                    }
                    // --- END: Coin Pattern Logic ---
                }
            }

            // This will now spawn enemies, power-ups, or single coins
            if (type) {
                obstacles.push(new Obstacle(lane, size, type));
            }
        }

        function checkCollision(playerBounds, obstacle) {
            const obsBounds = obstacle.getBounds(getLaneCenters());

            return playerBounds.x < obsBounds.x + obsBounds.width &&
                   playerBounds.x + obsBounds.width > obsBounds.x &&
                   playerBounds.y < obsBounds.y + obsBounds.height &&
                   playerBounds.y + obsBounds.height > obsBounds.y;
        }

        function getPlayerBounds(x) {
            const collisionSize = PLAYER_SIZE * COLLISION_SIZE_RATIO;
            const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
            return {
                x: x - collisionSize / 2,
                y: playerCenterY - collisionSize / 2,
                width: collisionSize,
                height: collisionSize,
                centerX: x,
                centerY: playerCenterY
            };
        }

        // Function to activate the magnet power-up
        function activateMagnet(currentTime) {
            isMagnetActive = true;
            isSlowingDown = false; 
            magnetStartTime = currentTime;
            magnetDurationMS = currentMagnetDuration * 1000; // Use dynamically calculated duration
            magnetProgressContainer.classList.remove('opacity-0');
            playPowerupSound();

            // Remove any other magnet power-ups currently on screen
            obstacles = obstacles.filter(obstacle => obstacle.type !== 'magnet' && obstacle.type !== 'jetpack');
        }
        
        // Function to end the magnet power-up cleanly
        function deactivateMagnet() {
            isMagnetActive = false;
            isSlowingDown = false;
            magnetProgressContainer.classList.add('opacity-0');
        }

        // NEW: Function to activate the Jetpack power-up
        function activateJetpack(currentTime) {
            isJetpackActive = true;
            gameState = 'BOOSTING'; // Set game state to boosting
            jetpackDurationMS = currentJetpackDuration * 1000; // Use dynamic duration
            boostEndTime = currentTime + jetpackDurationMS; // Set the end time
            
            playBoostSound(); // Start boost sound
            boostingText.classList.remove('hidden'); // Show "BOOSTING" text
            jetpackProgressContainer.classList.remove('opacity-0'); // Show progress bar
            playPowerupSound();

            if (isMagnetActive) deactivateMagnet(); // NEW: Deactivate magnet if one is active
            // Remove all enemies and other power-ups from the screen
            obstacles = obstacles.filter(obstacle => obstacle.type === 'coin');
        }

        // NEW: Function to end the Jetpack power-up cleanly
        function deactivateJetpack(isGameReset = false) {
            if (!isJetpackActive && !isGameReset) return; // Don't do anything if not active (unless it's a reset)

            isJetpackActive = false;
            jetpackProgressContainer.classList.add('opacity-0');
            
            // NEW: Set jetpack cooldown only if it's ending mid-game, not on a reset
            if (!isGameReset) {
                const currentTime = performance.now();
                const minCooldown = 30 * 1000; // 30 seconds
                const maxCooldown = 120 * 1000; // 120 seconds
                const randomCooldown = Math.random() * (maxCooldown - minCooldown) + minCooldown;
                jetpackCooldownEndTime = currentTime + randomCooldown;
            } else {
                 jetpackCooldownEndTime = 0; // Ensure no cooldown at game start
            }
            
            // Note: Sound and boostingText are stopped in the gameLoop or pauseGame
        }

        // NEW: Function to end the repair kit power-up cleanly
        function deactivateRepairKit() {
            isRepairKitActive = false;
            repairKitProgressContainer.classList.add('opacity-0');
        }
        
        // NEW: Function to activate repair kit during gameplay
        function activateRepairKitInGame() {
            const now = performance.now();
            // Only activate if playing, not already active, and not on cooldown
            if ((gameState !== 'PLAYING' && gameState !== 'BOOSTING') || isRepairKitActive || now < repairKitCooldownEndTime) {
                return;
            }

            if (spendRepairKit()) { // spendRepairKit() already updates UI and count
                isRepairKitActive = true;
                repairKitEndTime = now + (REPAIR_KIT_DURATION_SECONDS * 1000);
                repairKitCooldownEndTime = 0; // Reset cooldown when a new one is activated
                repairKitProgressContainer.classList.remove('opacity-0');
                playPowerupSound();
            }
        }


        /**
         * Function to handle coin collection (BOOSTING ONLY)
         * --- FIX: This now ONLY handles the 'BOOSTING' state auto-collect ---
         */
        function handleCoinCollection() {
            // Collect all coins during boosting
            // OLD: if (!isMagnetActive && gameState !== 'BOOSTING') return;
            if (gameState !== 'BOOSTING') return; // NEW: Only runs when boosting

            let collectedCount = 0;
            
            // Loop backwards to safely modify the array
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                // Collect any non-hit coin
                if (obstacle.type === 'coin' && !obstacle.isHit) {
                    obstacle.isHit = true; // Mark it as hit
                    
                    // *** FIX: CALCULATE COIN VALUE BASED ON MULTIPLIER ***
                    const coinValue = 1 + coinMultiplierLevel; 
                    
                    // Magnet Level 5 bonus REMOVED
                    // OLD: if (isMagnetActive && magnetLevel === MAGNET_MAX_LEVEL) { ... }
                    if (gameState === 'BOOSTING') {
                        runCoins += 5; // Keep boost bonus
                    } else {
                        // This branch is never hit due to the check at the start of the function
                        runCoins += coinValue; 
                    }

                    collectedCount++;
                }
            }

            if (collectedCount > 0) {
                runCoinsValueElement.textContent = runCoins;
                // To prevent audio stuttering at high speeds, we only play it every 5th frame
                if (Math.floor(score) % 5 === 0) {
                    playCoinSound(); 
                }
            }

            // Filter out collected coins (enemies and magnets remain)
            obstacles = obstacles.filter(o => o.type !== 'coin' || !o.isHit);
        }

        function drawGame(laneCenters, currentTime) {
            ctx.save();
            
            const isShaking = (gameState === 'SHAKING' && currentTime < shakeEndTime);
            if (isShaking) {
                const elapsed = shakeEndTime - currentTime;
                const progress = elapsed / SHAKE_DURATION; // Goes from 1 to 0
                const magnitude = SHAKE_MAGNITUDE * progress * progress; // Ease-out effect
                const x = (Math.random() - 0.5) * 2 * magnitude;
                const y = (Math.random() - 0.5) * 2 * magnitude;
                ctx.translate(x, y);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Draw Rain Effect ---
            // Draw rain after clearing screen but before other elements
            if (isRaining) {
                rainEffect.draw(ctx);
            }
            // --- End Rain Effect ---

            // Draw lane lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            const lineOffset = (canvas.width * LANE_WIDTH_PERCENTAGE) / 2;
            ctx.beginPath();
            ctx.moveTo(getLaneCenterX(0) + lineOffset, 0);
            ctx.lineTo(getLaneCenterX(0) + lineOffset, canvas.height);
            ctx.moveTo(getLaneCenterX(2) - lineOffset, 0);
            ctx.lineTo(getLaneCenterX(2) - lineOffset, canvas.height);
            ctx.stroke();

            const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
            const playerDrawX = playerX - PLAYER_SIZE / 2;
            const playerDrawY = playerCenterY - PLAYER_SIZE / 2;

            // Draw player jet
            if (playerImg.isLoaded) {
                // --- NEW: Dynamic Fire Exhaust Effect ---
                if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                    const flameBaseY = playerDrawY + PLAYER_SIZE * 0.9; // Start flame just inside the jet
                    
                    // Set a consistent flame size
                    const baseFlameWidth = PLAYER_SIZE * 0.4;
                    const baseFlameHeight = PLAYER_SIZE * 0.5;

                    // Create a flickering effect by varying height and width
                    const flameHeight = baseFlameHeight + (Math.random() * baseFlameHeight * 0.4);
                    const flameFlickerWidth = baseFlameWidth + (Math.random() * 10 - 5);

                    // Outer flame (yellow/orange)
                    ctx.fillStyle = `rgba(255, ${180 + Math.random() * 55}, 0, 0.7)`;
                    ctx.beginPath();
                    ctx.moveTo(playerX - flameFlickerWidth / 2, flameBaseY);
                    ctx.lineTo(playerX + flameFlickerWidth / 2, flameBaseY);
                    ctx.lineTo(playerX, flameBaseY + flameHeight);
                    ctx.closePath();
                    ctx.fill();

                    // Inner flame (brighter, smaller)
                    const innerFlameHeight = flameHeight * 0.6;
                    const innerFlameWidth = flameFlickerWidth * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 150, 0.9)`;
                    ctx.beginPath();
                    ctx.moveTo(playerX - innerFlameWidth / 2, flameBaseY);
                    ctx.lineTo(playerX + innerFlameWidth / 2, flameBaseY);
                    ctx.lineTo(playerX, flameBaseY + innerFlameHeight);
                    ctx.closePath();
                    ctx.fill();
                }

                // If magnet is active, draw a blue glow around the player
                if (isMagnetActive) {
                    const maxBlur = 30;
                    let blur = 0;
                    // --- FIX: Logic simplified as slowdown is 0 ---
                    if (isSlowingDown) { // This will now always be false, but harmless
                        const timeSlowing = (magnetStartTime + magnetDurationMS) - performance.now();
                        const ratio = timeSlowing / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                        blur = Math.max(0, maxBlur * ratio); 
                    } else {
                        blur = maxBlur;
                    }
                    
                    ctx.shadowColor = 'orange'; // This was the original glow color
                    ctx.shadowBlur = blur;
                }

                // NEW: Draw a cyan glow if Repair Kit is active
                if (isRepairKitActive) {
                    const maxBlur = 30;
                    const timeLeft = repairKitEndTime - performance.now();
                    let blur = maxBlur;
                    // Flicker effect in the last 3 seconds
                    if (timeLeft <= 3000) {
                         blur = maxBlur * (0.5 + Math.abs(Math.sin(performance.now() / 50))); // Flicker
                    }
                    
                    ctx.shadowColor = 'cyan'; // Cyan
                    ctx.shadowBlur = blur;
                }

                // NEW: Draw a white shield/glow if invincible after reviving
                if (performance.now() < reviveInvincibilityEndTime) {
                    const invincibilityProgress = (reviveInvincibilityEndTime - performance.now()) / 2000; // 2-second duration
                    ctx.shadowColor = `rgba(255, 234, 0, ${0.8 * invincibilityProgress})`; // Fade out effect
                    ctx.shadowBlur = 30 * invincibilityProgress;
                }

                ctx.drawImage(playerImg, playerDrawX, playerDrawY, PLAYER_SIZE, PLAYER_SIZE);
                ctx.shadowColor = 'transparent'; // Reset shadow
                ctx.shadowBlur = 0;
            } else {
                // Fallback drawing if image is still loading
                ctx.fillStyle = isMagnetActive ? '#2563eb' : '#3b82f6'; 
                ctx.beginPath();
                ctx.moveTo(playerX, playerDrawY);
                ctx.lineTo(playerDrawX, playerDrawY + PLAYER_SIZE);
                ctx.lineTo(playerDrawX + PLAYER_SIZE, playerDrawY + PLAYER_SIZE);
                ctx.closePath();
                ctx.fill();
            }

            // Draw obstacles
            obstacles.forEach(obstacle => obstacle.draw(ctx, laneCenters));
            
            // --- NEW: Draw Explosions ---
            explosions.forEach(p => p.draw(ctx));

            // When PAUSED, draw a semi-transparent dark overlay on top of the game
            if (gameState === 'PAUSED') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            ctx.restore();
        }

        // --- Game Control Functions ---
        
        function showModal(modalElement) {
            // Hide all modals
            gameModal.classList.add('hidden');
            pauseMenuModal.classList.add('hidden');
            settingsModal.classList.add('hidden'); // NEW: Hide settings modal
            importStatusMessage.classList.add('hidden'); // NEW: Hide import status

            
            // Show the requested modal
            modalElement.classList.remove('hidden');
        }

        function pauseGame() {
            if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                const wasBoosting = gameState === 'BOOSTING';
                
                gameState = 'PAUSED';
                if (isRaining) rainSound.pause(); // Pause rain sound
                if (wasBoosting) stopBoostSound(); // Stop boost sound
                
                boostingText.classList.add('hidden'); // Hide text
                resumeButton.classList.remove('hidden'); // Show resume button in-game
                
                checkQuestCompletion(); // NEW: Check for quest notifications
                showModal(pauseMenuModal);
            } else if (gameState === 'START') {
                // Allow opening pause menu from the main screen
                resumeButton.classList.add('hidden'); // Hide resume button on main menu
                
                checkQuestCompletion(); // NEW: Check for quest notifications
                showModal(pauseMenuModal);
            }
        }

        function unpauseGame() {
            // If unpausing from the main menu, just hide the modal.
            if (gameState === 'START') {
                showModal(gameModal); // Hides pause menu, shows main menu
                return;
            }

            // If not in a paused state (e.g., from main menu), do nothing.
            if (gameState !== 'PAUSED') {
                return;
            }

            // Determine if we need to go back to BOOSTING or PLAYING
            const newGameState = (performance.now() < boostEndTime) ? 'BOOSTING' : 'PLAYING'; // Simplified check
            gameState = newGameState;
            
            if (isRaining) playRainSound(); // Resume rain sound
            if (newGameState === 'BOOSTING') {
                playBoostSound();
                boostingText.classList.remove('hidden');
            }
            
            showModal(gameModal); // This hides all modals...
            gameModal.classList.add('hidden'); // ...so we explicitly hide the main one too.
            
            // Crucial: Reset lastTime to current time
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
        
        function initializeGame(useHeadstart = false) {
            initAudio(); // NEW: Call to unlock audio
            // Reset state
            score = 0;
            runCoins = 0;
            baseGameSpeed = INITIAL_GAME_SPEED;
            currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
            speedLevel = 0;
            obstacles = [];
            currentLane = 1;
            targetLane = 1;
            setupCanvas();
            playerX = getLaneCenterX(currentLane);
            
            // Re-load data to ensure current magnet/jetpack level and jet are used
            currentReviveCost = INITIAL_REVIVE_COST; // NEW: Reset revive cost
            loadGameData(); 
            updateMagnetDuration();
            updateJetpackDuration(); // NEW

            // Set up headstart state
            if (useHeadstart) {
                score = HEADSTART_SCORE;
                gameState = 'BOOSTING';
                isJetpackActive = false; // Headstart is not a jetpack
                boostEndTime = performance.now() + (HEADSTART_DURATION_SECONDS * 1000);
                playBoostSound();
                boostingText.classList.remove('hidden');
            } else {
                gameState = 'PLAYING';
                boostEndTime = 0;
                boostingText.classList.add('hidden');
            }

            // Reset Magnet State
            deactivateMagnet();
            // NEW: Reset Repair Kit UI State
            deactivateRepairKit();
            // NEW: Reset Jetpack State
            deactivateJetpack(true); // Pass true to indicate a reset
            
            // --- UPDATED Rain Cycle Logic: Randomize Start ---
            const MAX_CYCLE_MS = RAIN_CYCLE_DURATION_MS * 2;
            rainTimer = Math.random() * MAX_CYCLE_MS; // Randomize start time
            isRaining = rainTimer < RAIN_CYCLE_DURATION_MS; // Check initial state
            
            rainEffect.stop();
            rainEffect.clear();

            // Set initial background and rain state based on the randomized start
            if (isRaining) {
                stopRainSound(); // Stop any previous instance before starting a new one
                rainEffect.start();
                playRainSound();
                document.body.style.background = RAIN_BACKGROUND; // Dark Red (Body)
                canvas.style.background = DARK_CANVAS_BACKGROUND; // New: Dark Red (Canvas)
            } else {
                document.body.style.background = DEFAULT_BACKGROUND; // Bright Red (Body)
                canvas.style.background = SNOW_CANVAS_BACKGROUND; // New: Snow Color (Canvas)
                // Stop sounds that shouldn't play when it's not raining
                stopRainSound();
                playBackgroundMusic(); // Start music if it's not raining
            }
            // --- END UPDATED Rain Cycle Logic ---
            
            shakeEndTime = 0;
            reviveInvincibilityEndTime = 0; // Reset revive invincibility

            // Hide Modals and show Pause Button
            showModal(gameModal); // Hide all modals
            gameModal.classList.add('hidden'); // Then hide the main one
            finalScore.classList.add('hidden');
            coinsEarned.classList.add('hidden');
            scoreValueElement.textContent = Math.floor(score).toLocaleString(); // Update initial score
            runCoinsValueElement.textContent = '0';
            pauseButton.classList.remove('hidden'); // Ensure pause button is visible

            // --- NEW: Update 'Play Game' Quest ---
            if (!useHeadstart) { // Don't count headstart use as a "play" until they retry
                updateQuestProgress('play_game', 1);
            }
            // --- End Quest Update ---

            lastTime = performance.now(); // Set lastTime before starting loop
            requestAnimationFrame(gameLoop);
        }
        
        // Wrapper function for the START button
        function startGame() {
            initializeGame(false); // No headstart
        }
        
        // NEW function for Headstart button
        function startWithHeadstart() {
            // Can't use both powerups at once
            if (spendHeadstart()) { 
                initializeGame(true); // Headstart
            } else {
                console.error("Cannot use headstart: None left.");
            }
        } 


        // NEW: Function to handle reviving the player
        function revivePlayer() {
            initAudio(); // NEW: Call to unlock audio
            if (spendCoins(currentReviveCost)) {
                // --- NEW: Track money spent ---
                const storedSpent = localStorage.getItem(MONEY_SPENT_KEY);
                let moneySpent = storedSpent ? parseInt(storedSpent, 10) : 0;
                moneySpent += currentReviveCost;
                localStorage.setItem(MONEY_SPENT_KEY, moneySpent);
                // --- END: Track money spent ---

                // Clear obstacles near the player to give them a safe start
                const playerY = canvas.height * PLAYER_Y_POS_RATIO;
                obstacles = obstacles.filter(obs => {
                    const obsBottom = obs.y + obs.size;
                    // Remove obstacles that are in the player's half of the screen
                    return obsBottom < playerY - (canvas.height * 0.2) || obs.y > playerY + (canvas.height * 0.2);
                });

                // Grant 2 seconds of invincibility
                reviveInvincibilityEndTime = performance.now() + 2000;

                // --- NEW: Update 'Play Game' Quest on Revive ---
                // A revive counts as continuing the game, but let's count it as a "play"
                updateQuestProgress('play_game', 1);
                // --- End Quest Update ---

                // NEW: Double the revive cost for the next use
                currentReviveCost *= 2;

                // Resume the game
                gameState = 'PLAYING';
                gameModal.classList.add('hidden');
                pauseButton.classList.remove('hidden');
                lastTime = performance.now(); // Reset time to prevent frame jump
                requestAnimationFrame(gameLoop);
            }
        }


        function finishGameOver() {
            gameState = 'GAMEOVER';
            pauseButton.classList.add('hidden'); // Hide pause button on game over

            // Save persistent coins to local storage
            saveCoins(runCoins);
            
            // --- NEW: Save High Score ---
            const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
            const highScore = storedHighScore ? parseInt(storedHighScore, 10) : 0;
            if (score > highScore) {
                localStorage.setItem(HIGH_SCORE_KEY, Math.floor(score));
            }
            // --- END: Save High Score ---

            // --- NEW: Update Quest Progress on Game Over ---
            updateQuestProgress('score_run', Math.floor(score));
            updateQuestProgress('coins_run', runCoins);
            updateQuestProgress('total_meters', Math.floor(score));
            if(runCoins > 0) {
                updateQuestProgress('total_coins', runCoins);
            }
            // --- End Quest Update ---
            
            // Stop all sounds/effects
            deactivateMagnet();
            deactivateRepairKit(); // NEW
            deactivateJetpack(); // NEW
            if (isRaining) {
                isRaining = false;
                rainEffect.stop();
                stopRainSound(); 
            }
            stopBackgroundMusic(); // Also stop music on game over
            stopBoostSound(); // Stop any lingering boost sound from a previous run

            // Reset backgrounds
            document.body.style.background = DEFAULT_BACKGROUND; 
            canvas.style.background = SNOW_CANVAS_BACKGROUND;

            // Show Game Over Modal
            showModal(gameModal);
            modalTitle.textContent = "FLIGHT TERMINATED";
            modalMessage.textContent = "You collided with a enemy aircraft!";
            
            // Reload data to update headstart/repair kit counts on buttons
            loadGameData(); 
            
            // --- NEW: Revive Button Logic ---
            reviveButton.innerHTML = `REVIVE ($${currentReviveCost.toLocaleString()})`;
            if (totalCoins >= currentReviveCost) {
                reviveButton.classList.remove('hidden');
            } else {
                reviveButton.classList.add('hidden');
            }
            startButton.textContent = "RETRY";
            startButton.classList.remove('hidden'); // Ensure retry button is visible

            finalScore.textContent = `FINAL SCORE: ${Math.floor(score).toLocaleString()} meters`;
            finalScore.classList.remove('hidden');

            coinsEarned.textContent = `Coins Earned: $ ${runCoins}`;
            coinsEarned.classList.remove('hidden');
        }

        function gameOver() {
            // Can't game over during boost or post-revive invincibility
            if (gameState === 'BOOSTING' || performance.now() < reviveInvincibilityEndTime) return; 
            
            // --- NEW: Check for active Repair Kit ---
            if (isRepairKitActive) {
                deactivateRepairKit(); // Deactivate the kit
                playPowerupSound(); // Play a sound to indicate it was used
                
                // Grant 2 seconds of invincibility
                reviveInvincibilityEndTime = performance.now() + 2000;
                
                // Clear obstacles near the player
                const playerY = canvas.height * PLAYER_Y_POS_RATIO;
                obstacles = obstacles.filter(obs => {
                    const obsBottom = obs.y + obs.size;
                    return obsBottom < playerY - (canvas.height * 0.2) || obs.y > playerY + (canvas.height * 0.2);
                });
                
                // Create a small "shield" visual effect
                createExplosion(playerX, canvas.height * PLAYER_Y_POS_RATIO, 20); // Fewer particles for a "pop"
                
                return; // Prevent the game over
            }
            // --- End Repair Kit Check ---
            
            gameState = 'SHAKING';
            shakeEndTime = performance.now() + SHAKE_DURATION;
            playDeathSound();

            // --- NEW: Trigger explosion at player's last position ---
            createExplosion(playerX, canvas.height * PLAYER_Y_POS_RATIO);
        }

        // --- NEW: Export Save Data Function ---
        function exportSaveData() {
            try {
                const saveData = {};
                ALL_STORAGE_KEYS.forEach(key => {
                    const value = localStorage.getItem(key);
                    if (value !== null) {
                        saveData[key] = value;
                    }
                });

                const jsonString = JSON.stringify(saveData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'jetsurfers2-save.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            } catch (e) {
                console.error("Error exporting save data:", e);
                importStatusMessage.textContent = "Error exporting data.";
                importStatusMessage.classList.remove('hidden');
                setTimeout(() => importStatusMessage.classList.add('hidden'), 3000);
            }
        }

        // --- NEW: Import Save Data Function ---
        function importSaveData() {
            const file = importFileInput.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonString = e.target.result;
                    const saveData = JSON.parse(jsonString);

                    // Basic validation
                    if (typeof saveData !== 'object' || saveData === null || !saveData.hasOwnProperty(COIN_STORAGE_KEY)) {
                        throw new Error('Invalid save file format. Missing core data.');
                    }

                    // Clear all known keys before importing
                    ALL_STORAGE_KEYS.forEach(key => {
                        localStorage.removeItem(key);
                    });
                    
                    // Import new data
                    for (const key in saveData) {
                        if (saveData.hasOwnProperty(key)) {
                            // Ensure the key is one of the known keys (optional, but safer)
                            if (ALL_STORAGE_KEYS.includes(key)) {
                                localStorage.setItem(key, saveData[key]);
                            }
                        }
                    }
                    
                    // Show success message and reload
                    importStatusMessage.textContent = 'Save data imported! Reloading...';
                    importStatusMessage.classList.remove('hidden');
                    setTimeout(() => {
                        location.reload();
                    }, 2000); // Wait 2 seconds before reloading

                } catch (error) {
                    console.error('Failed to import save data:', error);
                    importStatusMessage.textContent = 'Error: Invalid or corrupt save file.';
                    importStatusMessage.classList.remove('hidden');
                    setTimeout(() => {
                        importStatusMessage.classList.add('hidden');
                    }, 3000); // Hide error after 3 seconds
                } finally {
                    // Reset file input to allow importing the same file again
                    importFileInput.value = '';
                }
            };
            reader.readAsText(file);
        }


        // --- Game Loop ---
        let animationFrameId = null; // To keep track of the animation frame
        function gameLoop(currentTime) {
            if (!lastTime) lastTime = currentTime; // Initialize lastTime on the first frame

            if (gameState === 'START' || gameState === 'GAMEOVER') {
                lastTime = currentTime;
                animationFrameId = requestAnimationFrame(gameLoop); // Keep loop running for input checks
                return;
            }
            
            if (gameState === 'PAUSED') {
                 drawGame(getLaneCenters(), currentTime);
                 animationFrameId = requestAnimationFrame(gameLoop); // Keep loop running for modal interaction
                 return;
            }

            deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // --- NEW: Update and filter explosion particles ---
            explosions.forEach(p => p.update());
            explosions = explosions.filter(p => p.alpha > 0);
            
            // --- Check for Headstart/Jetpack Boost Expiration (UPDATED) ---
            if (gameState === 'BOOSTING') {
                if (currentTime > boostEndTime) {
                    gameState = 'PLAYING'; // End boost
                    stopBoostSound();
                    boostingText.classList.add('hidden');
                    if (isJetpackActive) { // NEW: Check if it was a jetpack
                        deactivateJetpack(); // No parameter, defaults to false
                    }
                } else if (score >= HEADSTART_SCORE && !isJetpackActive) { // Only end early for Headstarts
                    // If the score already reached the target, switch to normal speed
                    gameState = 'PLAYING';
                    stopBoostSound();
                    boostingText.classList.add('hidden');
                }
            }
            
            // --- Rain Cycle Logic ---
            rainTimer += (deltaTime * 1000);
            
            if (rainTimer >= RAIN_CYCLE_DURATION_MS * 2) {
                rainTimer -= (RAIN_CYCLE_DURATION_MS * 2); // Reset cycle (240s total)
            }
            
            if (rainTimer < RAIN_CYCLE_DURATION_MS) {
                // First 120 seconds: Raining
                if (!isRaining) {
                    isRaining = true; // Set state to raining
                    rainEffect.start();
                    playRainSound(); // Start rain sound
                    stopBackgroundMusic(); // Stop music when rain starts
                    document.body.style.background = RAIN_BACKGROUND; // Change body to Dark Red
                    canvas.style.background = DARK_CANVAS_BACKGROUND; // Change canvas to Dark Red/Black
                }
            } else {
                // Second 120 seconds: Cooldown
                if (isRaining) {
                    isRaining = false;
                    rainEffect.stop();
                    stopRainSound(); // Stop rain sound
                    if (gameState === 'PLAYING') playBackgroundMusic(); // Start music when rain stops during gameplay
                    document.body.style.background = DEFAULT_BACKGROUND; // Revert body to Bright Red
                    canvas.style.background = SNOW_CANVAS_BACKGROUND; // Revert canvas to Snow Color
                }
            }

            if (isRaining) {
                rainEffect.update(); // Update particle positions
            } else {
                rainEffect.clear(); // Clear particles when not raining
            }
            // --- End Rain Cycle Logic ---
            
            const laneCenters = getLaneCenters();

            if (gameState === 'SHAKING') {
                if (currentTime > shakeEndTime) {
                    finishGameOver();
                    animationFrameId = requestAnimationFrame(gameLoop); // Continue loop in GAMEOVER state
                    return;
                }
                
                // Obstacles still move during shake
                obstacles = obstacles.filter(obstacle => {
                    // --- FIX: Pass correct arguments to update ---
                    obstacle.update(currentEffectiveGameSpeed * 60, deltaTime, isMagnetActive, getPlayerBounds(playerX));
                    return obstacle.y < canvas.height;
                });
                
                drawGame(laneCenters, currentTime);
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            // --- 'PLAYING' or 'BOOSTING' state ---
            const playerBounds = getPlayerBounds(playerX);

            // 1. Update Base Game Speed
            if (gameState !== 'BOOSTING') {
                // NEW: Cap the speed increase once the score reaches 50,000
                if (score <= 50000) {
                    const newSpeedLevel = Math.floor(score / SPEED_INCREMENT_SCORE);
                    if (newSpeedLevel > speedLevel) {
                        speedLevel = newSpeedLevel;
                        baseGameSpeed = INITIAL_GAME_SPEED * (1 + (speedLevel * SPEED_INCREMENT_AMOUNT));
                    }
                }
            } else {
                // If boosting (Headstart or Jetpack), use high speed multiplier
                // Base speed is set relative to score, but multiplier overrides
            }

            // 2. Update Effective Game Speed (Magnet/Headstart/Jetpack Effect)
            let speedMultiplier = 1;
            
            if (gameState === 'BOOSTING') {
                speedMultiplier = HEADSTART_SPEED_MULTIPLIER; // Use same speed for Jetpack
            } else if (isMagnetActive) {
                const timeElapsed = currentTime - magnetStartTime;
                const timeLeft = magnetDurationMS - timeElapsed;
                
                // --- FIX: Logic simplified as boost is 1 and slowdown is 0 ---
                if (timeLeft <= 0) {
                    deactivateMagnet();
                } else if (timeLeft <= MAGNET_SLOWDOWN_TIME_SECONDS * 1000) { // This block will be skipped
                    isSlowingDown = true;
                    const slowDownRatio = timeLeft / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                    const speedRange = MAGNET_BOOST_MULTIPLIER - 1;
                    speedMultiplier = 1 + (speedRange * Math.max(0, slowDownRatio)); 
                } else {
                    speedMultiplier = MAGNET_BOOST_MULTIPLIER; // This is 1
                }

                const progress = (timeLeft / magnetDurationMS) * 100;
                magnetProgressBar.style.width = `${progress}%`;

            } else {
                isSlowingDown = false;
            }
            
            currentEffectiveGameSpeed = baseGameSpeed * speedMultiplier; // Multiplier will be 1 if magnet active

            // 2b. NEW: Update Repair Kit Timer
            if (isRepairKitActive) {
                const timeLeft = repairKitEndTime - currentTime;
                if (timeLeft <= 0) {
                    deactivateRepairKit();
                    repairKitCooldownEndTime = currentTime + 5000; // Start 5-second cooldown
                } else {
                    // Update progress bar
                    const progress = (timeLeft / (REPAIR_KIT_DURATION_SECONDS * 1000)) * 100;
                    repairKitProgressBar.style.width = `${progress}%`;
                }
            }
            
            // 2c. NEW: Update Jetpack Timer (only if active)
            if (isJetpackActive && gameState === 'BOOSTING') {
                const timeLeft = boostEndTime - currentTime;
                if (timeLeft > 0) {
                    const progress = (timeLeft / jetpackDurationMS) * 100;
                    jetpackProgressBar.style.width = `${progress}%`;
                }
            }
            
            // 3. Score Update
            let scoreIncrement = currentEffectiveGameSpeed * 10 * deltaTime;
            // NEW: Add a massive score multiplier when the jetpack is active
            if (isJetpackActive) {
                scoreIncrement *= 10; // Make the score go insanely fast!
            }
            score += scoreIncrement;


            // 4. Update Player Position
            const targetX = getLaneCenterX(targetLane);
            playerX += (targetX - playerX) * PLAYER_MOVE_SPEED;
            if (Math.abs(playerX - targetX) < 1) {
                currentLane = targetLane;
            }

            // 5. Update Obstacles
            obstacles = obstacles.filter(obstacle => {
                // --- FIX: Pass all required arguments to update ---
                obstacle.update(currentEffectiveGameSpeed * 60, deltaTime, isMagnetActive, playerBounds);
                return obstacle.y < canvas.height;
            });

            // 6. Spawn new obstacle
            if (currentTime - lastObstacleTime > 1600 / (currentEffectiveGameSpeed * 0.8)) {
                spawnObstacle();
                lastObstacleTime = currentTime;
            }

            // 7. Coin Collection Logic (BOOSTING ONLY)
            // --- FIX: Magnet pull is handled in Obstacle.update ---
            // handleCoinCollection now internally checks for 'BOOSTING' state
            handleCoinCollection();
            
            // 8. Collision Detection
            obstacles.forEach(obstacle => {
                if (!obstacle.isHit && checkCollision(playerBounds, obstacle)) {
                    obstacle.isHit = true;
                    
                    if (obstacle.type === 'enemy') {
                        // --- FIX: Removed !isMagnetActive check. Magnet no longer grants invincibility. ---
                        if (gameState !== 'BOOSTING' && performance.now() > reviveInvincibilityEndTime) {
                            gameOver();
                        }
                        // If boosting, the enemy is destroyed (filtered out next step)
                    
                    // --- FIX: Simplified coin collection. Always collect on contact. No magnet bonus. ---
                    } else if (obstacle.type === 'coin') {
                        // Collect on contact, magnet or not.
                        const coinValue = 1 + coinMultiplierLevel;
                        
                        // REMOVED: Magnet level 5 bonus
                        runCoins += coinValue;

                        runCoinsValueElement.textContent = runCoins;
                        playCoinSound();

                    } else if (obstacle.type === 'magnet') {
                        activateMagnet(currentTime);
                    } else if (obstacle.type === 'jetpack') { // NEW: Collect Jetpack
                        activateJetpack(currentTime);
                    }
                }
            });

            // 9. Remove collected/destroyed items
            // Destroyed enemies are filtered out here if isHit is true (due to protection)
            obstacles = obstacles.filter(o => (o.type !== 'coin' && o.type !== 'magnet' && o.type !== 'enemy' && o.type !== 'jetpack') || !o.isHit);

            // 10. Draw
            drawGame(laneCenters, currentTime);

            // 11. Update UI
            scoreValueElement.textContent = Math.floor(score).toLocaleString();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners & Initialization ---

        // 1. Handle resize
        window.addEventListener('resize', setupCanvas);

        // 2. Start Buttons (Updated)
        startButton.addEventListener('click', startGame);
        useHeadstartButton.addEventListener('click', startWithHeadstart);
        reviveButton.addEventListener('click', revivePlayer); // NEW

        // 3. Pause Button & Menu Handlers
        pauseButton.addEventListener('click', pauseGame);
        resumeButton.addEventListener('click', unpauseGame);
        quitButton.addEventListener('click', finishGameOver); // NEW: Quit button ends the run
        
        shopButton.addEventListener('click', () => {
            // Don't change game state, just navigate
            window.location.href = 'shop.html';
        }); 
        
        // --- NEW: Settings Menu Logic ---
        settingsButton.addEventListener('click', () => {
            // Load and display the high score when opening settings
            const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
            const highScore = storedHighScore ? parseInt(storedHighScore, 10) : 0;
            settingsHighScoreValue.textContent = `${highScore.toLocaleString()} m`;

            // NEW: Load and display jets owned count
            // This correctly counts all owned jets and the total number of jets from jets-data.js
            const jetsOwnedCount = ownedJets.length;
            const totalJetsCount = JETS.length;

            document.getElementById('settingsJetsOwnedValue').textContent = `${jetsOwnedCount}/${totalJetsCount}`;

            showModal(settingsModal); // Show the new settings modal
        });

        settingsBackButton.addEventListener('click', () => {
            showModal(pauseMenuModal); // Go back to the pause menu
        });

        // --- NEW: Export/Import Listeners ---
        exportSaveButton.addEventListener('click', exportSaveData);
        importSaveButton.addEventListener('click', () => importFileInput.click()); // Trigger hidden file input
        importFileInput.addEventListener('change', importSaveData); // Handle file selection


        // 4. Input Handling
        function handleInput(isRight) {
            if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                if (isRight && targetLane < NUM_LANES - 1) {
                    targetLane++;
                } else if (!isRight && targetLane > 0) {
                    targetLane--;
                }
            }
        }

        // --- Swipe Detection State ---
        let touchStartX = 0;
        let touchStartY = 0;

        // Keyboard Input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                handleInput(true);
            } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                handleInput(false);
            } else if (e.key.toLowerCase() === 'r') { // NEW: Double-press 'R' for Repair Kit
                const now = performance.now();
                if (now - lastKeypressTime < DOUBLE_PRESS_THRESHOLD) {
                    activateRepairKitInGame();
                    lastKeypressTime = 0; // Reset after activation
                } else {
                    lastKeypressTime = now;
                }
            } else if (e.key === 'Enter' && (gameState === 'GAMEOVER' || gameState === 'START')) {
                 // Only allow Enter to start/retry from the main modal
                if (!gameModal.classList.contains('hidden')) {
                    startGame();
                }
            } else if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
                if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                    pauseGame();
                } else if (gameState === 'PAUSED') {
                    // If in pause menu or settings menu, unpause
                    if (!pauseMenuModal.classList.contains('hidden') || !settingsModal.classList.contains('hidden')) {
                        unpauseGame();
                    }
                } 
            }
        });

        // Touch/Click Input (Mobile friendly)
        canvas.addEventListener('mousedown', (e) => { // Keep for desktop clicking
            if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            handleInput(x > canvas.width / 2); // True if tapped on the right half
        });
        
        // --- NEW: Swipe Controls for Mobile ---
        canvas.addEventListener('touchstart', (e) => {
            // NEW: Double-tap to activate repair kit
            const now = performance.now();
            if (now - lastTapTime < DOUBLE_PRESS_THRESHOLD) {
                // Check if the tap is roughly in the same place
                // We use the *previous* touchStartX from the last tap
                if (Math.abs(e.touches[0].clientX - touchStartX) < 30 && Math.abs(e.touches[0].clientY - touchStartY) < 30) {
                    activateRepairKitInGame();
                    lastTapTime = 0; // Reset after activation
                    e.preventDefault(); // Prevent swipe logic from firing
                    return; // Stop processing this touch
                }
            }
            lastTapTime = now;
            // --- End double-tap ---

            if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
            e.preventDefault();
            // Record the starting touch position
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
            e.preventDefault();
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 30; // Minimum pixels for a swipe

            // Check for a horizontal swipe that is long enough
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                handleInput(deltaX > 0); // True for right swipe, false for left
            }
        });
        
        // --- This is the content that was originally at the bottom ---
        loadGameData(); // Load all persistent data (coins, magnet level, jets, and headstarts)
        updateMagnetDuration(); // Ensure the duration is correct on startup

        handleConnectionChange(); // Initial check on page load

        updateJetpackDuration(); // NEW
        setupCanvas();
        
        // Initialize background to default state on load
        document.body.style.background = DEFAULT_BACKGROUND; 
        canvas.style.background = SNOW_CANVAS_BACKGROUND;
        
        checkQuestCompletion(); // NEW: Check for quest notifications
        
        // Start the game loop
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId); // Clear any previous loop
        }
        animationFrameId = requestAnimationFrame(gameLoop);

        // --- NEW: Handle Loading Screen Visibility ---
        // Always show the loading screen
        const loadingScreen = document.getElementById('loadingScreen');
        loadingScreen.style.display = 'flex'; // Make sure it's visible
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500); // CSS transition duration
        }, 2500); // Show for 2.5 seconds
    }

</script>
</body>
</html>