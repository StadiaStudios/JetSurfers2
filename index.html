<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JetSurfers 2</title>
    <script src="weather/snowfall_effect.js"></script>
    <script src="weather/rain_effect.js"></script> <!-- Added rain effect script -->
    <link rel="icon" href="rec/xmas-icon.jpg" type="image/png">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom Styles for Game Canvas and UI */
        body {
            font-family: 'Inter', sans-serif;
            /* Default background, will be set by JS on load using DEFAULT_BACKGROUND constant */
            background: linear-gradient(180deg, #ce0303 0%, #850202 100%); /* Initial Red Gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
            /* Added transition for smooth background color change */
            transition: background 0.8s ease;
        }
        #gameContainer {
            width: 100%;
            max-width: 450px; /* Default for mobile/small screen */
            aspect-ratio: 9/16; /* Standard mobile aspect ratio */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(180deg, #1f2937 0%, #111827 100%); /* Darker gradient for the structure */
            position: relative;
        }

        /* Desktop specific styles for larger canvas */
        @media (min-width: 768px) {
            #gameContainer {
                max-width: 600px; /* Bigger size for desktop */
            }
        }
        
        #gameCanvas {
            display: block;
            /* Background will be set dynamically by JavaScript */
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            /* Allows touches to pass through the UI elements to the canvas */
            pointer-events: none;
        }
        .top-bar {
            position: absolute;
            top: 15px;
            /* Use full width and let padding handle spacing */
            width: 100%; 
            display: flex;
            justify-content: space-between; /* Distribute items */
            align-items: center;
            color: #f3f4f6;
            font-weight: bold;
            font-size: 1rem;
            padding: 0 15px; /* Padding on both sides */
        }
        .score-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            min-width: 80px; /* Ensure boxes are readable */
            justify-content: center;
            margin-left: 10px; /* Spacing between the three score/coin boxes */
        }
        .coin-icon {
            /* Now an image, not a star text */
            width: 18px; 
            height: 18px;
            margin-right: 6px;
            /* Added object-fit for visual consistency */
            object-fit: contain; 
        }
        .modal {
            background: rgba(17, 24, 39, 0.98);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(201, 204, 209, 0.8);
            border: 2px solid white;
            pointer-events: auto; /* Re-enable pointer events for the modal */
            max-width: 90%; /* Allow modal to be slightly wider for shop */
            width: 400px;
            max-height: 90vh; /* Ensure modal fits on screen */
            overflow-y: auto; /* Allow scrolling if content is too tall */
            z-index: 20; /* Ensure modal is on top */
        }
        
        .game-button {
            padding: 10px 25px;
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            background-color: #3b82f6;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #1e40af;
        }
        .game-button:hover {
            background-color: #2563eb;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #1e40af;
        }
        
        /* NEW Style for Headstart Button */
        #useHeadstartButton {
            background-color: #f59e0b; /* Amber/Orange */
            box-shadow: 0 4px #d97706;
            margin-top: 10px;
            padding: 8px 20px;
            font-size: 0.9rem;
        }
        #useHeadstartButton:hover {
            background-color: #eab308;
        }
        #useHeadstartButton:active {
            box-shadow: 0 2px #d97706;
        }


        /* --- Magnet Progress Bar Styles --- */
        #magnetProgressContainer {
            position: absolute;
            top: 60px; /* Below the top score bar */
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 16px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s;
            pointer-events: none;
            display: flex;
            align-items: center;
            padding: 0 4px;
        }
        #magnetProgressBar {
            height: 100%;
            background: linear-gradient(90deg, #fd0404, #ff5353); /* Blue gradient */
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 6px;
        }
        #magnetIcon {
            position: absolute;
            left: 8px;
            color: white;
            font-size: 0.9rem;
            z-index: 2;
        }

        /* --- Pause Button Styles --- */
        .pause-button {
            pointer-events: auto; /* Allow clicks */
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: background-color 0.15s;
            border: none; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .pause-button img {
            width: 20px;
            height: 20px;
            display: block;
            margin: 0;
        }
        
        /* --- Menu Button Styles for Pause Modal --- */
        .menu-button {
            display: block; /* Changed from width: 100% to ensure <a> tag behaves same */
            width: 100%;
            padding: 12px 0;
            margin: 8px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f3f4f6;
            background-color: #1f2937; /* Darker blue/gray */
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px #111827;
            text-decoration: none; /* Added for <a> tag */
            text-align: center; /* Added for <a> tag */
        }

        .menu-button:hover {
            background-color: #374151;
        }

        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #111827;
        }
        
        /* NEW: Boosting Text */
        #boostingText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: yellow;
            text-shadow: 0 0 10px red, 0 0 20px red;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay for Score and Modals -->
    <div class="ui-overlay">
        
        <!-- Pause Button (Positioned top left) -->
        <button id="pauseButton" class="pause-button absolute top-4 left-4 z-10 hidden">
            <!-- Updated to use a PNG image for better styling -->
            <img src="rec/pause_icon.png" alt="Pause" class="w-5 h-5" onerror="this.src='rec/pause_icon.png'">
        </button>
        
        <!-- Top Bar for Score and Coins -->
        <div class="top-bar">
            <!-- Left-aligned items -->
            <div class="flex items-center">
                <!-- Headstart Inventory Display (New) -->
                <div id="headstartInventoryBox" class="score-box" style="min-width: unset; pointer-events: auto; margin-left: 45px;">
                    <img src="rec/items/headstart.png" alt="Headstart" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjEgMTBIM3oiLz48cGF0aCBkPSJNMjEgMTZIMyIvPjwvc3ZnPg=='">
                    <span id="headstartCount">0</span>
                </div>
            </div>
            <!-- Right-aligned items -->
            <div class="flex items-center">
                <!-- Score Display -->
                <div class="score-box">
                    Score: <span id="scoreValue">0</span> m
                </div>
                <!-- Current Run Coins -->
                <div class="score-box">
                    <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHBhdGg+PC9wYXRoPjwvc3ZnPg=='"> 
                    Earned: <span id="runCoinsValue">0</span>
                </div>
                <!-- Total Persistent Coins -->
                <div class="score-box">
                    <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHBhdGg+PC9wYXRoPjwvc3ZnPg=='">
                    <span id="totalCoinsValue">0</span>
                </div>
            </div>
        </div>

        <!-- Magnet Progress Bar -->
        <div id="magnetProgressContainer" class="opacity-0">
            <span id="magnetIcon">ðŸ§²</span>
            <div id="magnetProgressBar"></div>
        </div>


        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <h1 id="modalTitle" class="text-3xl font-extrabold mb-4 text-cyan-400">JET SURFERS II</h1>
            <p id="modalMessage" class="text-lg mb-6">
                Collect coins and avoid oncoming aircrafts.
            </p>
            <p class="text-sm mb-6 text-gray-300">
                Controls:<br>
                Desktop: A or Left Arrow / D or Right Arrow<br>
                Mobile: Tap Left / Right side of the screen
            </p>
            <button id="startButton" class="game-button">START FLIGHT</button>
            <button id="useHeadstartButton" class="game-button hidden">USE HEADSTART (<span id="startHeadgetCount">0</span>)</button>

            <div id="finalScore" class="text-xl font-bold mt-4 hidden"></div>
            <div id="coinsEarned" class="text-xl font-bold text-yellow-400 mt-2 hidden"></div>
        </div>

        <!-- Pause Menu Modal -->
        <div id="pauseMenuModal" class="modal hidden">
            <h2 class="text-3xl font-extrabold mb-8 text-white">PAUSED</h2>
            <button id="resumeButton" class="menu-button">RESUME FLIGHT</button>
            <button id="shopButton" class="menu-button">UPGRADES SHOP</button>
            <!-- UPDATED: This is now a link to shop.html -->
            <a href="jetshop.html" id="jetShopMenuButton" class="menu-button">JET SHOP</a>
            <button id="settingsButton" class="menu-button">SETTINGS</button>
            <p class="text-xs text-gray-500 mt-6">Game Version: v1.0.0</p>
        </div>
        
        <!-- NEW: Boosting Text Overlay -->
        <div id="boostingText" class="hidden">BOOSTING</div>

    </div>
</div>

<script>
    // --- Local Storage Setup (Shared Keys) ---
    // These keys are shared with shop.html
    const COIN_STORAGE_KEY = 'jetSurferTotalCoins';
    const MAGNET_LEVEL_KEY = 'jetSurferMagnetLevel';
    const JET_OWNED_KEY = 'jetSurferOwnedJets';
    const JET_SELECTED_KEY = 'jetSurferSelectedJet';
    // NEW KEY for Headstart count
    const HEADSTART_COUNT_KEY = 'jetSurferHeadstartCount';

    // --- START: Jet Definitions ---
    // This array MUST match the one in shop.html
    const JETS = [
        { id: 'default', name: 'Standard Issue', price: 0, img: 'rec/motor/default.png' },
        { id: 'blue_streak', name: 'Blue Streak', price: 500, img: 'rec/motor/jet_blue.png' }, // Placeholder
        { id: 'red_comet', name: 'Nightwing', price: 1000, img: 'rec/motor/nightwing.png' }, // Placeholder
        { id: 'gold_wing', name: 'Premium Jet', price: 5000, img: 'rec/motor/premium-jet.png' } // Placeholder
    ];
    const DEFAULT_JET_ID = 'default';
    
    let ownedJets = [DEFAULT_JET_ID];
    let selectedJetId = DEFAULT_JET_ID;
    // --- END: Jet Definitions ---

    let totalCoins = 0; // The persistent total
    let magnetLevel = 0; // The persistent magnet level (0 to 5)
    let headstartCount = 0; // The persistent headstart item count

    function loadGameData() {
        const storedCoins = localStorage.getItem(COIN_STORAGE_KEY);
        totalCoins = storedCoins ? parseInt(storedCoins, 10) : 0;
        
        const storedMagnetLevel = localStorage.getItem(MAGNET_LEVEL_KEY);
        magnetLevel = storedMagnetLevel ? parseInt(storedMagnetLevel, 10) : 0;
        
        const storedHeadstartCount = localStorage.getItem(HEADSTART_COUNT_KEY);
        headstartCount = storedHeadstartCount ? parseInt(storedHeadstartCount, 10) : 0;

        document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
        document.getElementById('headstartCount').textContent = headstartCount.toLocaleString();

        // --- Load Jet Data ---
        const storedOwnedJets = localStorage.getItem(JET_OWNED_KEY);
        ownedJets = storedOwnedJets ? JSON.parse(storedOwnedJets) : [DEFAULT_JET_ID];

        const storedSelectedJet = localStorage.getItem(JET_SELECTED_KEY);
        selectedJetId = storedSelectedJet ? storedSelectedJet : DEFAULT_JET_ID;
        
        // Apply the selected jet image
        const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
        playerImg.src = selectedJet.img;
        
        // Show/Hide Headstart button on start screen
        const headstartButton = document.getElementById('useHeadstartButton');
        document.getElementById('startHeadgetCount').textContent = headstartCount;
        if (headstartCount > 0) {
            headstartButton.classList.remove('hidden');
        } else {
            headstartButton.classList.add('hidden');
        }
    }

    function saveCoins(coinsEarned) {
        if (coinsEarned > 0) {
            totalCoins += coinsEarned;
        }
        localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
        document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
    }
    
    // --- Headstart Inventory Management ---
    function spendHeadstart() {
        if (headstartCount > 0) {
            headstartCount--;
            localStorage.setItem(HEADSTART_COUNT_KEY, headstartCount);
            document.getElementById('headstartCount').textContent = headstartCount;
            // Hide the button on the modal if no more are left
            if (headstartCount === 0) {
                document.getElementById('useHeadstartButton').classList.add('hidden');
            }
            return true;
        }
        return false;
    }
    // --- End Headstart Inventory Management ---

    // --- Jet/Coin Functions (Still needed for loading) ---
    function spendCoins(amount) {
        if (totalCoins >= amount) {
            totalCoins -= amount;
            localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
            document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
            return true; // Purchase successful
        }
        return false; // Not enough coins
    }

    function saveOwnedJets() {
        localStorage.setItem(JET_OWNED_KEY, JSON.stringify(ownedJets));
    }

    function saveSelectedJet() {
        localStorage.setItem(JET_SELECTED_KEY, selectedJetId);
        // Also update the playerImg.src immediately
        const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
        playerImg.src = selectedJet.img;
        playerImg.isLoaded = false; // Force reload
        playerImg.onload = () => { playerImg.isLoaded = true; };
    }
    // --- End: Jet/Coin Functions ---

    function saveMagnetLevel(newLevel) {
        magnetLevel = newLevel;
        localStorage.setItem(MAGNET_LEVEL_KEY, newLevel);
        updateMagnetDuration(); // Recalculate duration when level changes
    }


    // --- Canvas Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');
    const rainEffect = new RainEffect(canvas); // Initialize rain effect

    // UI Elements
    const scoreValueElement = document.getElementById('scoreValue');
    const runCoinsValueElement = document.getElementById('runCoinsValue');
    const totalCoinsValueElement = document.getElementById('totalCoinsValue');
    const gameModal = document.getElementById('gameModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const startButton = document.getElementById('startButton');
    const finalScore = document.getElementById('finalScore');
    const coinsEarned = document.getElementById('coinsEarned');
    const useHeadstartButton = document.getElementById('useHeadstartButton');
    const boostingText = document.getElementById('boostingText');

    // UI Elements for Pause Menu
    const pauseButton = document.getElementById('pauseButton');
    const pauseMenuModal = document.getElementById('pauseMenuModal');
    const resumeButton = document.getElementById('resumeButton');
    const shopButton = document.getElementById('shopButton');
    const settingsButton = document.getElementById('settingsButton');

    // NEW UI ELEMENTS for Magnet
    const magnetProgressContainer = document.getElementById('magnetProgressContainer');
    const magnetProgressBar = document.getElementById('magnetProgressBar');

    // Game Constants
    const NUM_LANES = 3;
    const LANE_WIDTH_PERCENTAGE = 0.25;
    const PLAYER_SIZE = 60;
    const COLLISION_SIZE_RATIO = 0.7;
    const PLAYER_Y_POS_RATIO = 0.8;
    const PLAYER_MOVE_SPEED = 0.15;
    const INITIAL_GAME_SPEED = 4;
    const SPEED_INCREMENT_SCORE = 1000;
    const SPEED_INCREMENT_AMOUNT = 0.02;
    
    // Headstart Constants (NEW)
    const HEADSTART_SCORE = 20000;
    const HEADSTART_DURATION_SECONDS = 10;
    const HEADSTART_SPEED_MULTIPLIER = 20;
    
    // Magnet State Variables and Constants
    const MAGNET_DURATION_SECONDS_BASE = 10; // Base duration
    const MAGNET_DURATION_BONUS_PER_LEVEL = 2; // +2 seconds per level
    const MAGNET_MAX_LEVEL = 5;
    
    let currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE; // Actual duration used in game
    
    const MAGNET_BOOST_MULTIPLIER = 3.5;
    const MAGNET_SLOWDOWN_TIME_SECONDS = 2; 
    const MAGNET_SPAWN_CHANCE = 0.05; 

    // Dynamic Magnet Duration Calculation
    function updateMagnetDuration() {
        currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE + (magnetLevel * MAGNET_DURATION_BONUS_PER_LEVEL);
    }
    
    // Initial calculation (must be called after loading magnetLevel)
    updateMagnetDuration(); 


    // State variables
    // Added 'BOOSTING' state
    let gameState = 'START'; // Possible states: 'START', 'PLAYING', 'PAUSED', 'SHAKING', 'GAMEOVER', 'BOOSTING'
    let score = 0;
    let runCoins = 0;
    let baseGameSpeed = INITIAL_GAME_SPEED;
    let currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
    let lastTime = 0;
    let deltaTime = 0;
    let lastObstacleTime = 0;
    let currentLane = 1;
    let targetLane = 1;
    let playerX = 0;
    let obstacles = [];
    let speedLevel = 0;

    let isMagnetActive = false;
    let magnetDurationMS = 0; // duration in milliseconds, set on activation
    let magnetStartTime = 0;
    let isSlowingDown = false;
    
    let shakeEndTime = 0;
    const SHAKE_MAGNITUDE = 10;
    const SHAKE_DURATION = 300;
    
    let boostEndTime = 0; // NEW: Headstart tracking

    // --- Background Styles (Updated for Red Theme) ---
    // Default background (Red)
    const DEFAULT_BACKGROUND = 'linear-gradient(180deg, #DC2626 0%, #991B1B 100%)'; 
    // Darker, stormy, spaceous red gradient
    const RAIN_BACKGROUND = 'linear-gradient(180deg, #450A0A 0%, #6D2828 100%)'; 

    // --- Canvas Background Styles (NEW) ---
    const SNOW_CANVAS_BACKGROUND = 'linear-gradient(90deg, #FFFAFA 0%, #aecdf7 100%)'; /* Light Blue Sky Gradient */
    const DARK_CANVAS_BACKGROUND = 'linear-gradient(0deg, #1A0505 0%, #300A0A 100%)'; 
    
    // --- Rain State Variables ---
    let rainTimer = 0;
    let isRaining = false;
    const RAIN_CYCLE_DURATION_MS = 120 * 1000; // 120 seconds

    // Player/Coin Images
    const playerImg = new Image();
    // playerImg.src is set by loadGameData()
    playerImg.isLoaded = false;
    playerImg.onload = () => { playerImg.isLoaded = true; };
    playerImg.onerror = () => { 
        console.error("Failed to load selected jet image. Loading default.");
        playerImg.src = 'rec/motor/default.png'; // Fallback
        playerImg.isLoaded = false; // Re-trigger onload
        playerImg.onload = () => { playerImg.isLoaded = true; };
    };

    const coinImg = new Image();
    coinImg.src = "rec/items/coin.png"; 
    coinImg.isLoaded = false;
    coinImg.onload = () => { coinImg.isLoaded = true; };
    coinImg.onerror = () => { console.error("Failed to load coin image."); };
    
    const magnetImg = new Image();
    magnetImg.src = "rec/collectible/magnet.png"; 
    magnetImg.isLoaded = false;
    magnetImg.onload = () => { magnetImg.isLoaded = true; };
    magnetImg.onerror = () => { console.error("Failed to load magnet image. Using fallback."); };

    // --- Audio Setup ---
    const coinSound = new Audio('sfx/coin.mp3');
    const deathSound = new Audio('sfx/dead.mp3');
    const powerupSound = new Audio('sfx/powerup.mp3'); 
    const rainSound = new Audio('sfx/ambience/rain.mp3'); // Added rain sound
    const boostSound = new Audio('sfx/boost.mp3'); // NEW: Boost sound

    coinSound.volume = 0.5; 
    deathSound.volume = 1.0;
    powerupSound.volume = 1.0;
    rainSound.loop = true;
    rainSound.volume = 1.0; // Set rain volume to be ambient
    boostSound.volume = 1.0;
    boostSound.loop = true;


    function playCoinSound() {
        coinSound.currentTime = 0; 
        coinSound.play().catch(e => console.error("Coin audio playback failed (expected if MP3 is missing):", e));
    }

    function playDeathSound() {
        deathSound.currentTime = 0; 
        deathSound.play().catch(e => console.error("Death audio playback failed (expected if MP3 is missing):", e));
    }

    function playPowerupSound() {
        powerupSound.currentTime = 0;
        powerupSound.play().catch(e => console.error("Powerup audio playback failed (expected if MP3 is missing):", e));
    }

    function playRainSound() {
        rainSound.play().catch(e => console.error("Rain audio playback failed (expected if MP3 is missing):", e));
    }
    
    function stopRainSound() {
        rainSound.pause();
        rainSound.currentTime = 0;
    }
    
    function playBoostSound() {
        boostSound.currentTime = 0;
        boostSound.play().catch(e => console.error("Boost audio playback failed (expected if MP3 is missing):", e));
    }
    
    function stopBoostSound() {
        boostSound.pause();
        boostSound.currentTime = 0;
    }


    // --- Object Classes (Unchanged) ---

    class Obstacle {
        constructor(lane, size, type = 'enemy') {
            this.lane = lane;
            this.size = size;
            this.y = -size;
            this.type = type;
            this.isHit = false;
        }

        update(speed, dt) {
            this.y += speed * dt;
        }

        draw(ctx, lanePos) {
            const xCenter = lanePos[this.lane];
            const y = this.y;

            if (this.type === 'enemy') {
                // Enemy Plane (Red/Black)
                ctx.fillStyle = this.isHit ? 'rgba(255, 0, 0, 0.8)' : 'rgba(239, 68, 68, 0.9)';
                ctx.beginPath();
                // Simple delta wing shape
                ctx.moveTo(xCenter, y);
                ctx.lineTo(xCenter - this.size / 2, y + this.size);
                ctx.lineTo(xCenter + this.size / 2, y + this.size);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(xCenter - this.size * 0.1, y + this.size * 0.2, this.size * 0.2, this.size * 0.5); // Cockpit
            } else if (this.type === 'coin') {
                // Coin
                if (coinImg.isLoaded) {
                    ctx.drawImage(coinImg, xCenter - this.size / 2, y, this.size, this.size);
                } else {
                    ctx.fillStyle = '#FFEB3B';
                    ctx.beginPath();
                    ctx.arc(xCenter, y + this.size / 2, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (this.type === 'magnet') {
                 // Magnet Power-up
                if (magnetImg.isLoaded) {
                    // Draw image if loaded
                    ctx.drawImage(magnetImg, xCenter - this.size / 2, y, this.size, this.size);
                } else {
                    // Fallback to a purple square with an icon
                    ctx.fillStyle = '#9333ea'; // Deep Purple
                    ctx.fillRect(xCenter - this.size / 2, y, this.size, this.size);
                    ctx.fillStyle = 'white';
                    ctx.font = `${this.size * 0.6}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ðŸ§²', xCenter, y + this.size / 2 + 2);
                }
            }
        }

        getBounds(lanePos) {
            const xCenter = lanePos[this.lane];
            return {
                x: xCenter - this.size / 2,
                y: this.y,
                width: this.size,
                height: this.size
            };
        }
    }


    // --- Game Logic ---

    function setupCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        playerX = getLaneCenterX(currentLane);
        
        // Update rain effect canvas reference and re-init particles for new size
        rainEffect.canvas = canvas;
        if (isRaining) {
            rainEffect.init();
        }
    }

    function getLaneCenterX(laneIndex) {
        const laneWidth = canvas.width * LANE_WIDTH_PERCENTAGE;
        return (canvas.width / 2) + (laneIndex - 1) * laneWidth;
    }

    function getLaneCenters() {
        const centers = [];
        for (let i = 0; i < NUM_LANES; i++) {
            centers.push(getLaneCenterX(i));
        }
        return centers;
    }

    function spawnObstacle() {
        // Do not spawn enemies/magnets during a Headstart boost
        if (gameState === 'BOOSTING') {
            // Only allow coins to spawn during boost
            const lane = Math.floor(Math.random() * NUM_LANES);
            const size = 50;
            const type = 'coin';
            obstacles.push(new Obstacle(lane, size, type));
            return;
        }
        
        const lane = Math.floor(Math.random() * NUM_LANES);
        const size = 50;
        let type = 'enemy';

        const coinRoll = Math.random();

        if (coinRoll < 0.3) { // 30% chance of an item spawn
            const itemRoll = Math.random();
            if (itemRoll < MAGNET_SPAWN_CHANCE) { 
                type = 'magnet';
            } else {
                type = 'coin';
            }
        }

        obstacles.push(new Obstacle(lane, size, type));
    }

    function checkCollision(playerBounds, obstacle) {
        const obsBounds = obstacle.getBounds(getLaneCenters());

        return playerBounds.x < obsBounds.x + obsBounds.width &&
               playerBounds.x + playerBounds.width > obsBounds.x &&
               playerBounds.y < obsBounds.y + obsBounds.height &&
               playerBounds.y + obsBounds.height > obsBounds.y;
    }

    function getPlayerBounds(x) {
        const collisionSize = PLAYER_SIZE * COLLISION_SIZE_RATIO;
        const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
        return {
            x: x - collisionSize / 2,
            y: playerCenterY - collisionSize / 2,
            width: collisionSize,
            height: collisionSize,
            centerX: x,
            centerY: playerCenterY
        };
    }

    // Function to activate the magnet power-up
    function activateMagnet(currentTime) {
        isMagnetActive = true;
        isSlowingDown = false; 
        magnetStartTime = currentTime;
        magnetDurationMS = currentMagnetDuration * 1000; // Use dynamically calculated duration
        magnetProgressContainer.classList.remove('opacity-0');
        playPowerupSound();
    }
    
    // Function to end the magnet power-up cleanly
    function deactivateMagnet() {
        isMagnetActive = false;
        isSlowingDown = false;
        magnetProgressContainer.classList.add('opacity-0');
    }

    /**
     * Function to handle coin collection (still screen-wide)
     */
    function handleCoinCollection() {
        // Collect all coins during magnet or boosting
        if (!isMagnetActive && gameState !== 'BOOSTING') return;

        let collectedCount = 0;
        
        // Loop backwards to safely modify the array
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            
            // Collect any non-hit coin
            if (obstacle.type === 'coin' && !obstacle.isHit) {
                obstacle.isHit = true; // Mark it as hit
                
                // Magnet Level 5 bonus
                if (isMagnetActive && magnetLevel === MAGNET_MAX_LEVEL) {
                    runCoins += 15;
                } else if (gameState === 'BOOSTING') {
                    runCoins += 20; // Extra coin bonus during headstart
                } else {
                    runCoins++;
                }

                collectedCount++;
            }
        }

        if (collectedCount > 0) {
            runCoinsValueElement.textContent = runCoins;
            // To prevent audio stuttering at high speeds, we only play it every 5th frame
            if (Math.floor(score) % 5 === 0) {
                playCoinSound(); 
            }
        }

        // Filter out collected coins (enemies and magnets remain)
        obstacles = obstacles.filter(o => o.type !== 'coin' || !o.isHit);
    }

    function drawGame(laneCenters, currentTime) {
        ctx.save();
        
        const isShaking = (gameState === 'SHAKING' && currentTime < shakeEndTime);
        if (isShaking) {
            const elapsed = shakeEndTime - currentTime;
            const progress = elapsed / SHAKE_DURATION; // Goes from 1 to 0
            const magnitude = SHAKE_MAGNITUDE * progress * progress; // Ease-out effect
            const x = (Math.random() - 0.5) * 2 * magnitude;
            const y = (Math.random() - 0.5) * 2 * magnitude;
            ctx.translate(x, y);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- Draw Rain Effect ---
        // Draw rain after clearing screen but before other elements
        if (isRaining) {
            rainEffect.draw(ctx);
        }
        // --- End Rain Effect ---

        // Draw lane lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 3;
        const lineOffset = (canvas.width * LANE_WIDTH_PERCENTAGE) / 2;
        ctx.beginPath();
        ctx.moveTo(getLaneCenterX(0) + lineOffset, 0);
        ctx.lineTo(getLaneCenterX(0) + lineOffset, canvas.height);
        ctx.moveTo(getLaneCenterX(2) - lineOffset, 0);
        ctx.lineTo(getLaneCenterX(2) - lineOffset, canvas.height);
        ctx.stroke();

        const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
        const playerDrawX = playerX - PLAYER_SIZE / 2;
        const playerDrawY = playerCenterY - PLAYER_SIZE / 2;

        // Draw player jet
        if (playerImg.isLoaded) {
            // Draw speed lines/afterburner effect for BOOSTING state (NEW)
            if (gameState === 'BOOSTING') {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                const flameHeight = PLAYER_SIZE * 0.5;
                const flameWidth = PLAYER_SIZE * 0.6;
                ctx.beginPath();
                ctx.moveTo(playerX - flameWidth / 2, playerDrawY + PLAYER_SIZE);
                ctx.lineTo(playerX + flameWidth / 2, playerDrawY + PLAYER_SIZE);
                ctx.lineTo(playerX, playerDrawY + PLAYER_SIZE + flameHeight);
                ctx.closePath();
                ctx.fill();
            }

            // If magnet is active, draw a blue glow around the player
            if (isMagnetActive) {
                const maxBlur = 30;
                let blur = 0;
                if (isSlowingDown) {
                    const timeSlowing = (magnetStartTime + magnetDurationMS) - performance.now();
                    const ratio = timeSlowing / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                    blur = Math.max(0, maxBlur * ratio); 
                } else {
                    blur = maxBlur;
                }
                
                ctx.shadowColor = 'red';
                ctx.shadowBlur = blur;
            }
            ctx.drawImage(playerImg, playerDrawX, playerDrawY, PLAYER_SIZE, PLAYER_SIZE);
            ctx.shadowColor = 'transparent'; // Reset shadow
            ctx.shadowBlur = 0;
        } else {
            // Fallback drawing if image is still loading
            ctx.fillStyle = isMagnetActive ? '#2563eb' : '#3b82f6'; 
            ctx.beginPath();
            ctx.moveTo(playerX, playerDrawY);
            ctx.lineTo(playerDrawX, playerDrawY + PLAYER_SIZE);
            ctx.lineTo(playerDrawX + PLAYER_SIZE, playerDrawY + PLAYER_SIZE);
            ctx.closePath();
            ctx.fill();
        }

        // Draw obstacles
        obstacles.forEach(obstacle => obstacle.draw(ctx, laneCenters));
        
        // When PAUSED, draw a semi-transparent dark overlay on top of the game
        if (gameState === 'PAUSED') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.restore();
    }

    // --- Game Control Functions ---
    
    function showModal(modalElement) {
        // Hide all modals
        gameModal.classList.add('hidden');
        pauseMenuModal.classList.add('hidden');
        
        // Show the requested modal
        modalElement.classList.remove('hidden');
    }

    function pauseGame() {
        if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
        
        const wasBoosting = gameState === 'BOOSTING';
        
        gameState = 'PAUSED';
        if (isRaining) rainSound.pause(); // Pause rain sound
        if (wasBoosting) stopBoostSound(); // Stop boost sound
        
        boostingText.classList.add('hidden'); // Hide text

        showModal(pauseMenuModal);
        // The game loop will stop execution on the next frame check
    }

    function unpauseGame() {
        if (gameState !== 'PAUSED') return;
        
        // Determine if we need to go back to BOOSTING or PLAYING
        const newGameState = (performance.now() < boostEndTime && score < HEADSTART_SCORE) ? 'BOOSTING' : 'PLAYING';
        gameState = newGameState;
        
        if (isRaining) playRainSound(); // Resume rain sound
        if (newGameState === 'BOOSTING') {
            playBoostSound();
            boostingText.classList.remove('hidden');
        }
        
        showModal(gameModal); // Hides all modals
        gameModal.classList.add('hidden'); // Ensure no modal is visible
        
        // Crucial: Reset lastTime to current time
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function initializeGame(useHeadstart = false) {
        // Reset state
        score = 0;
        runCoins = 0;
        baseGameSpeed = INITIAL_GAME_SPEED;
        currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
        speedLevel = 0;
        obstacles = [];
        currentLane = 1;
        targetLane = 1;
        setupCanvas();
        playerX = getLaneCenterX(currentLane);
        
        // Set up headstart state
        if (useHeadstart) {
            score = HEADSTART_SCORE;
            gameState = 'BOOSTING';
            boostEndTime = performance.now() + (HEADSTART_DURATION_SECONDS * 1000);
            playBoostSound();
            boostingText.classList.remove('hidden');
        } else {
            gameState = 'PLAYING';
            boostEndTime = 0;
            boostingText.classList.add('hidden');
        }

        // Re-load data to ensure current magnet level and jet are used
        loadGameData(); 
        updateMagnetDuration();

        // Reset Magnet State
        deactivateMagnet();
        
        // --- UPDATED Rain Cycle Logic: Randomize Start ---
        const MAX_CYCLE_MS = RAIN_CYCLE_DURATION_MS * 2;
        rainTimer = Math.random() * MAX_CYCLE_MS; // Randomize start time
        isRaining = rainTimer < RAIN_CYCLE_DURATION_MS; // Check initial state
        
        rainEffect.stop();
        rainEffect.clear();

        // Set initial background and rain state based on the randomized start
        if (isRaining) {
            stopRainSound(); // Stop any previous instance before starting a new one
            rainEffect.start();
            playRainSound();
            document.body.style.background = RAIN_BACKGROUND; // Dark Red (Body)
            canvas.style.background = DARK_CANVAS_BACKGROUND; // New: Dark Red (Canvas)
        } else {
            document.body.style.background = DEFAULT_BACKGROUND; // Bright Red (Body)
            canvas.style.background = SNOW_CANVAS_BACKGROUND; // New: Snow Color (Canvas)
            // Stop sounds that shouldn't play when it's not raining
            stopRainSound();
        }
        // --- END UPDATED Rain Cycle Logic ---
        
        shakeEndTime = 0;

        // Hide Modals and show Pause Button
        gameModal.classList.add('hidden');
        pauseMenuModal.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        finalScore.classList.add('hidden');
        coinsEarned.classList.add('hidden');
        scoreValueElement.textContent = Math.floor(score).toLocaleString(); // Update initial score
        runCoinsValueElement.textContent = '0';

        requestAnimationFrame(gameLoop);
    }
    
    // Wrapper function for the START button
    function startGame() {
        initializeGame(false);
    }
    
    // NEW function for Headstart button
    function startWithHeadstart() {
        if (spendHeadstart()) {
            initializeGame(true);
        } else {
            // Should not happen if button is correctly hidden/disabled
            console.error("Cannot use headstart: None left.");
        }
    }


    function finishGameOver() {
        gameState = 'GAMEOVER';

        // Save persistent coins to local storage
        saveCoins(runCoins);
        
        // Stop all sounds/effects
        deactivateMagnet();
        if (isRaining) {
            isRaining = false;
            rainEffect.stop();
            stopRainSound(); 
        }
        stopBoostSound(); // Stop any lingering boost sound from a previous run

        // Reset backgrounds
        document.body.style.background = DEFAULT_BACKGROUND; 
        canvas.style.background = SNOW_CANVAS_BACKGROUND;

        pauseButton.classList.add('hidden');

        // Show Game Over Modal
        showModal(gameModal);
        modalTitle.textContent = "FLIGHT TERMINATED";
        modalMessage.textContent = "You collided with a enemy aircraft!";
        startButton.textContent = "RETRY";
        
        // Reload data to update headstart count on button
        loadGameData(); 

        finalScore.textContent = `FINAL SCORE: ${Math.floor(score).toLocaleString()} meters`;
        finalScore.classList.remove('hidden');

        coinsEarned.textContent = `Coins Earned: $ ${runCoins}`;
        coinsEarned.classList.remove('hidden');
    }

    function gameOver() {
        // Can't game over during boost
        if (gameState === 'BOOSTING') return; 
        
        gameState = 'SHAKING';
        shakeEndTime = performance.now() + SHAKE_DURATION;
        playDeathSound();
    }


    // --- Game Loop ---
    function gameLoop(currentTime) {
        if (gameState === 'START' || gameState === 'GAMEOVER') {
            lastTime = currentTime;
            return;
        }
        
        if (gameState === 'PAUSED') {
             drawGame(getLaneCenters(), currentTime);
             return;
        }

        deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        
        // --- Check for Headstart Boost Expiration (NEW) ---
        if (gameState === 'BOOSTING') {
            if (currentTime > boostEndTime) {
                gameState = 'PLAYING'; // End boost
                stopBoostSound();
                boostingText.classList.add('hidden');
            } else if (score >= HEADSTART_SCORE) {
                // If the score already reached the target, switch to normal speed
                gameState = 'PLAYING';
                stopBoostSound();
                boostingText.classList.add('hidden');
            }
        }
        
        // --- Rain Cycle Logic ---
        rainTimer += (deltaTime * 1000);
        
        if (rainTimer >= RAIN_CYCLE_DURATION_MS * 2) {
            rainTimer -= (RAIN_CYCLE_DURATION_MS * 2); // Reset cycle (240s total)
        }
        
        if (rainTimer < RAIN_CYCLE_DURATION_MS) {
            // First 120 seconds: Raining
            if (!isRaining) {
                isRaining = true;
                rainEffect.start();
                playRainSound(); // Start rain sound
                document.body.style.background = RAIN_BACKGROUND; // Change body to Dark Red
                canvas.style.background = DARK_CANVAS_BACKGROUND; // Change canvas to Dark Red/Black
            }
        } else {
            // Second 120 seconds: Cooldown
            if (isRaining) {
                isRaining = false;
                rainEffect.stop();
                stopRainSound(); // Stop rain sound
                document.body.style.background = DEFAULT_BACKGROUND; // Revert body to Bright Red
                canvas.style.background = SNOW_CANVAS_BACKGROUND; // Revert canvas to Snow Color
            }
        }

        if (isRaining) {
            rainEffect.update(); // Update particle positions
        } else {
            rainEffect.clear(); // Clear particles when not raining
        }
        // --- End Rain Cycle Logic ---
        
        const laneCenters = getLaneCenters();

        if (gameState === 'SHAKING') {
            if (currentTime > shakeEndTime) {
                finishGameOver();
                return;
            }
            
            // Obstacles still move during shake
            obstacles = obstacles.filter(obstacle => {
                obstacle.update(currentEffectiveGameSpeed * 60, deltaTime);
                return obstacle.y < canvas.height;
            });
            
            drawGame(laneCenters, currentTime);
            requestAnimationFrame(gameLoop);
            return;
        }

        // --- 'PLAYING' or 'BOOSTING' state ---
        const playerBounds = getPlayerBounds(playerX);

        // 1. Update Base Game Speed
        if (gameState !== 'BOOSTING') {
            const newSpeedLevel = Math.floor(score / SPEED_INCREMENT_SCORE);
            if (newSpeedLevel > speedLevel) {
                speedLevel = newSpeedLevel;
                baseGameSpeed = INITIAL_GAME_SPEED * (1 + (speedLevel * SPEED_INCREMENT_AMOUNT));
            }
        } else {
            // If boosting, base speed is high
            baseGameSpeed = INITIAL_GAME_SPEED * (1 + (HEADSTART_SCORE / SPEED_INCREMENT_SCORE) * SPEED_INCREMENT_AMOUNT);
        }

        // 2. Update Effective Game Speed (Magnet/Headstart Effect)
        let speedMultiplier = 1;
        
        if (gameState === 'BOOSTING') {
            speedMultiplier = HEADSTART_SPEED_MULTIPLIER;
        } else if (isMagnetActive) {
            const timeElapsed = currentTime - magnetStartTime;
            const timeLeft = magnetDurationMS - timeElapsed;
            
            if (timeLeft <= 0) {
                deactivateMagnet();
            } else if (timeLeft <= MAGNET_SLOWDOWN_TIME_SECONDS * 1000) {
                isSlowingDown = true;
                const slowDownRatio = timeLeft / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                const speedRange = MAGNET_BOOST_MULTIPLIER - 1;
                speedMultiplier = 1 + (speedRange * Math.max(0, slowDownRatio)); 
            } else {
                speedMultiplier = MAGNET_BOOST_MULTIPLIER;
            }

            const progress = (timeLeft / magnetDurationMS) * 100;
            magnetProgressBar.style.width = `${progress}%`;

        } else {
            isSlowingDown = false;
        }
        
        currentEffectiveGameSpeed = baseGameSpeed * speedMultiplier;
        
        // 3. Score Update
        score += currentEffectiveGameSpeed * 10 * deltaTime; 

        // 4. Update Player Position
        const targetX = getLaneCenterX(targetLane);
        playerX += (targetX - playerX) * PLAYER_MOVE_SPEED;
        if (Math.abs(playerX - targetX) < 1) {
            currentLane = targetLane;
        }

        // 5. Update Obstacles
        obstacles = obstacles.filter(obstacle => {
            obstacle.update(currentEffectiveGameSpeed * 60, deltaTime);
            return obstacle.y < canvas.height;
        });

        // 6. Spawn new obstacle
        if (currentTime - lastObstacleTime > 1600 / (currentEffectiveGameSpeed * 0.8)) {
            spawnObstacle();
            lastObstacleTime = currentTime;
        }

        // 7. Coin Collection Logic (during Magnet or Boost)
        handleCoinCollection();
        
        // 8. Collision Detection
        obstacles.forEach(obstacle => {
            if (!obstacle.isHit && checkCollision(playerBounds, obstacle)) {
                obstacle.isHit = true;
                
                if (obstacle.type === 'enemy') {
                    // Collision only results in game over if not boosting or not under magnet protection
                    if (gameState !== 'BOOSTING' && !isMagnetActive) {
                        gameOver();
                    }
                    // If boosting or magnet is active, the enemy is destroyed (filtered out next step)
                } else if (obstacle.type === 'coin') {
                    // If not caught by magnet logic in handleCoinCollection, still collect on contact
                    if (!isMagnetActive) {
                         if (magnetLevel === MAGNET_MAX_LEVEL) {
                            runCoins += 15;
                        } else {
                            runCoins++;
                        }
                        runCoinsValueElement.textContent = runCoins;
                        playCoinSound();
                    }
                } else if (obstacle.type === 'magnet') {
                    activateMagnet(currentTime);
                }
            }
        });

        // 9. Remove collected/destroyed items
        // Destroyed enemies are filtered out here if isHit is true (due to protection)
        obstacles = obstacles.filter(o => (o.type !== 'coin' && o.type !== 'magnet' && o.type !== 'enemy') || !o.isHit);

        // 10. Draw
        drawGame(laneCenters, currentTime);

        // 11. Update UI
        scoreValueElement.textContent = Math.floor(score).toLocaleString();

        requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners & Initialization ---

    // 1. Handle resize
    window.addEventListener('resize', setupCanvas);

    // 2. Start Buttons (Updated)
    startButton.addEventListener('click', startGame);
    useHeadstartButton.addEventListener('click', startWithHeadstart);

    // 3. Pause Button & Menu Handlers
    pauseButton.addEventListener('click', pauseGame);
    resumeButton.addEventListener('click', unpauseGame);
    
    shopButton.addEventListener('click', () => {
        gameState = 'PAUSED'; 
        window.location.href = 'shop.html';
    }); 
    
    settingsButton.addEventListener('click', () => {
        // Temporarily use the main game modal to display a message, then unpause
        gameModal.classList.remove('hidden');
        pauseMenuModal.classList.add('hidden');
        modalTitle.textContent = "SETTINGS";
        modalMessage.textContent = "Version: v1.0.0. More Coming soon in Beta Development Stages.";
        startButton.textContent = "CONTINUE";

        const tempStartHandler = () => {
            gameModal.classList.add('hidden');
            unpauseGame(); 
            startButton.removeEventListener('click', tempStartHandler);
            startButton.addEventListener('click', startGame); 
        };
        
        startButton.removeEventListener('click', startGame);
        startButton.addEventListener('click', tempStartHandler);
    });

    // 4. Input Handling
    function handleInput(isRight) {
        if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
            if (isRight && targetLane < NUM_LANES - 1) {
                targetLane++;
            } else if (!isRight && targetLane > 0) {
                targetLane--;
            }
        }
    }

    // Keyboard Input
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
            handleInput(true);
        } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
            handleInput(false);
        } else if (e.key === 'Enter' && gameState !== 'PLAYING' && gameState !== 'BOOSTING') {
            if (gameState === 'PAUSED') {
                // Check which modal is open.
                if (!pauseMenuModal.classList.contains('hidden')) {
                   // In pause menu, don't unpause with Enter
                   return;
                }
                unpauseGame();
            } else if (gameState === 'GAMEOVER' || gameState === 'START') {
                startGame();
            }
        } else if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
            if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                pauseGame();
            } else if (gameState === 'PAUSED') {
                // If in pause menu, unpause
                if (!pauseMenuModal.classList.contains('hidden')) {
                    unpauseGame();
                }
            } 
        }
    });

    // Touch/Click Input (Mobile friendly)
    canvas.addEventListener('mousedown', (e) => {
        if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        handleInput(x > canvas.width / 2); // True if tapped on the right half
    });

    canvas.addEventListener('touchstart', (e) => {
        if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.touches[0].clientX - rect.left;
        handleInput(x > canvas.width / 2); // True if tapped on the right half
    });

    // Start initialization and game loop on load
    window.onload = function() {
        loadGameData(); // Load all persistent data (coins, magnet level, jets, and headstarts)
        updateMagnetDuration(); // Ensure the duration is correct on startup
        setupCanvas();
        pauseButton.classList.add('hidden'); 
        
        // Initialize background to default state on load
        document.body.style.background = DEFAULT_BACKGROUND; 
        canvas.style.background = SNOW_CANVAS_BACKGROUND;
        
        requestAnimationFrame(gameLoop);
    }

</script>
</body>
</html>
