<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JetSurfers 2</title>
    <script src="weather/snowfall_effect.js"></script>
    <script src="weather/rain_effect.js"></script> <!-- Added rain effect script -->
    <link rel="icon" href="rec/xmas-icon.jpg" type="image/png">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom Styles for Game Canvas and UI */
        body {
            font-family: 'Inter', sans-serif;
            /* Default background, will be set by JS on load using DEFAULT_BACKGROUND constant */
            background: linear-gradient(180deg, #9b9292 0%, #887575 100%); /* Initial Red Gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
            /* Added transition for smooth background color change */
            transition: background 0.8s ease;
        }
        #gameContainer {
            width: 100%;
            max-width: 450px; /* Default for mobile/small screen */
            aspect-ratio: 9/16; /* Standard mobile aspect ratio */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0);
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(180deg, #1f2937 0%, #111827 100%); /* Darker gradient for the structure */
            position: relative;
        }

        /* Desktop specific styles for larger canvas */
        @media (min-width: 768px) {
            #gameContainer {
                max-width: 600px; /* Bigger size for desktop */
            }
        }
        
        #gameCanvas {
            display: block;
            /* Background will be set dynamically by JavaScript */
            transition: background 0.8s ease; /* Added transition for smooth background color change */
            
        }

        #canvasContainer {
            width: 600px; /* Match canvas width */
            height: 400px; /* Fixed height for scrollable area */
            overflow-y: scroll; /* Enable vertical scrolling */
            position: relative;
            /* Custom scrollbar styling */
            scrollbar-width: thin; /* For Firefox */
            scrollbar-color: #888 #f1f1f1; /* For Firefox */
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;



            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            /* Allows touches to pass through the UI elements to the canvas */
            pointer-events: none;
        }
        .top-bar {
            position: absolute;
            top: 15px;
            /* Use full width and let padding handle spacing */
            width: 100%;
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap on small screens */
            justify-content: space-between;
            align-items: center;
            color: #f3f4f6;
            font-weight: bold;
            font-size: 1rem;
            padding: 0 15px; /* Padding on both sides */
        }
        .top-bar > div {
            flex-shrink: 0; /* Prevent flex items from shrinking */
        }
        .score-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            min-width: 80px; /* Ensure boxes are readable */
            justify-content: flex-start; /* Align content to the left */
            margin: 2px 4px; /* Add small margin for spacing when wrapped */
        }
        .score-box.score-main {
            flex-grow: 1; /* Allow score to take up space */
            justify-content: center; /* Center the main score text */
        }
        .coin-icon {
            /* Now an image, not a star text */
            width: 18px; 
            height: 18px;
            margin-right: 6px;
            /* Added object-fit for visual consistency */
            object-fit: contain; 
        }
        .modal {
            background: rgba(17, 24, 39, 0.98);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px red;
            border: 2px solid red;
            pointer-events: auto; /* Re-enable pointer events for the modal */
            max-width: 90%; /* Allow modal to be slightly wider for shop */
            width: 400px;
            max-height: 90vh; /* Ensure modal fits on screen */
            overflow-y: auto; /* Allow scrolling if content is too tall */
            z-index: 20; /* Ensure modal is on top */
        }
        
        .game-button {
            padding: 10px 25px;
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            background-color: #f63b3b;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px red;
        }
        .game-button:hover {
            background-color: #ff0000;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px red;
        }
        
        /* NEW Style for Headstart Button */
        #useHeadstartButton {
            background-color: #f59e0b; /* Amber/Orange */
            box-shadow: 0 4px #d97706;
            margin-top: 10px;
            padding: 8px 20px;
            font-size: 0.9rem;
        }
        #useHeadstartButton:hover {
            background-color: #eab308;
        }
        #useHeadstartButton:active {
            box-shadow: 0 2px #d97706;
        }


        /* --- Magnet Progress Bar Styles --- */
        #magnetProgressContainer {
            position: absolute;
            top: 60px; /* Below the top score bar */
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 16px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            transition: opacity 0.3s;
            pointer-events: none;
            display: flex;
            align-items: center;
            padding: 0 4px;
        }
        #magnetProgressBar {
            height: 100%;
            background: linear-gradient(90deg, #fd0404, #ff5353); /* Blue gradient */
            width: 0%;
            transition: width 0.1s linear;
            border-radius: 6px;
        }
        #magnetIcon {
            position: absolute;
            left: 8px;
            color: white;
            font-size: 0.9rem;
            z-index: 2;
        }

        /* --- Pause Button Styles --- */
        .pause-button {
            pointer-events: auto; /* Allow clicks */
            background: #ff5100;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: background-color 0.15s;
            border: none; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .pause-button img {
            width: 20px;
            height: 20px;
            display: block;
            margin: 0;
        }
        
        /* --- Menu Button Styles for Pause Modal --- */
        .menu-button {
            display: block; /* Changed from width: 100% to ensure <a> tag behaves same */
            width: 100%;
            padding: 12px 0;
            margin: 8px 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f3f4f6;
            background-color: #1f2937; /* Darker blue/gray */
            border: 2px solid red;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px #111827;
            text-decoration: none; /* Added for <a> tag */
            text-align: center; /* Added for <a> tag */
            position: relative; /* NEW: For notification icon */
        }

        .menu-button:hover {
            background-color: #374151;
        }

        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #111827;
        }
        
        /* NEW: Boosting Text */
        #boostingText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: yellow;
            text-shadow: 0 0 10px red, 0 0 20px red;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay for Score and Modals -->
    <div class="ui-overlay">
        
        <!-- Pause Button (Positioned top left) -->
        <button id="pauseButton" class="pause-button absolute top-4 left-4 z-10">
            <!-- Updated to use a PNG image for better styling -->
            <img src="rec/pause_icon.png" alt="Pause" class="w-5 h-5" onerror="this.src='rec/pause_icon.png'">
        </button>
        
        <!-- Top Bar for Score and Coins -->
        <div class="top-bar">
            <!-- Left-aligned items -->
            <div class="flex items-center" style="margin-left: 45px;">
                <!-- Headstart Inventory Display (New) -->
                <div id="headstartInventoryBox" class="score-box" style="min-width: unset; pointer-events: auto;">
                    <img src="rec/items/headstart.png" alt="Headstart" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjEgMTBIM3oiLz48cGF0aCBkPSJNMjEgMTZIMyIvPjwvc3ZnPg=='">
                    <span id="headstartCount">0</span>
                </div>
            </div>
            <!-- Center Score Display -->
            <div class="score-box score-main">
                <span id="scoreValue">0</span> m
            </div>
            <!-- Right-aligned coin items -->
            <div class="flex flex-col items-end">
                <!-- Current Run Coins -->
                <div class="score-box">
                    <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHBhdGg+PC9wYXRoPjwvc3ZnPg=='"> 
                    <span id="runCoinsValue">0</span>
                </div>
                <!-- Total Persistent Coins -->
                <div class="score-box">
                    <img src="rec/items/coin.png" alt="Coin" class="coin-icon" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MCA1MCI+PHBhdGg+PC9wYXRoPjwvc3ZnPg=='">
                    <span id="totalCoinsValue">0</span>
                </div>
            </div>
        </div>

        <!-- Magnet Progress Bar -->
        <div id="magnetProgressContainer" class="opacity-0">
            <span id="magnetIcon">ðŸ§²</span>
            <div id="magnetProgressBar"></div>
        </div>


        <!-- Start/Game Over Modal -->
        <div id="gameModal" class="modal">
            <h1 id="modalTitle" class="text-3xl font-extrabold mb-4 text-[white]">JET SURFERS <p style="color:red;">II</p></h1>
            <p id="modalMessage" class="text-lg mb-6">
                Collect coins and avoid oncoming aircrafts.
            </p>
            <p class="text-sm mb-6 text-gray-300">
                Controls:<br>
                Desktop: A or Left Arrow / D or Right Arrow | Can also tap on side<br>
                Mobile: Swipe Left / Right 
            </p>
            <button id="startButton" class="game-button">SPLASH</button>
            <button id="reviveButton" class="game-button hidden">REVIVE ($300)</button>
            <button id="useHeadstartButton" class="game-button hidden">USE HEADSTART (<span id="startHeadgetCount">0</span>)</button>

            <div id="finalScore" class="text-xl font-bold mt-4 hidden"></div>
            <div id="coinsEarned" class="text-xl font-bold text-yellow-400 mt-2 hidden"></div>
        </div>

        <!-- Pause Menu Modal -->
        <div id="pauseMenuModal" class="modal hidden">
            <h2 class="text-3xl font-extrabold mb-8 text-white">PAUSED</h2>
            <button id="resumeButton" class="menu-button">RESUME</button>
            <button id="quitButton" class="menu-button">QUIT</button>
            <button id="shopButton" class="menu-button">UPGRADES SHOP</button>
            <!-- UPDATED: This is now a link to shop.html -->
            <a href="jetshop.html" id="jetShopMenuButton" class="menu-button">JET SHOP</a>
            <!-- NEW: Link to stats.html -->
            <a href="stats.html" id="statsMenuButton" class="menu-button">USER STATS</a>
            <!-- NEW: Link to quests.html -->
            <a href="quests.html" id="questsMenuButton" class="menu-button">
                DAILY CHALLENGES
                <!-- NEW: Quest Notification Icon -->
                <img src="rec/exclamation.png" id="questNotificationIcon" class="hidden absolute top-0 right-0 w-10 h-10 -mt-2 -mr-2" alt="!" 
                     onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZHRoPSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSIjRkRFNCA0NyI+PGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTEgMTVIMTNWMTdIMTF6TTExIDdIMTNWMTNIMTF6Ii8+PC9zdmc+'; this.onerror=null;">
            </a>
            <button id="settingsButton" class="menu-button">SETTINGS</button>
            <p class="text-xs text-gray-500 mt-6">Game Version: v1.1.1</p>
        </div>
        
        <!-- NEW: Settings Menu Modal -->
        <div id="settingsModal" class="modal hidden">
            <h2 class="text-3xl font-extrabold mb-8 text-white">SETTINGS</h2>
            <p class="text-sm text-gray-400 mb-6">Backup your game data or restore it from a file.</p>
            <button id="exportDataButton" class="menu-button">EXPORT DATA</button>
            <button id="importDataButton" class="menu-button">IMPORT DATA</button>
            <!-- Hidden file input for the import process -->
            <input type="file" id="importFileInput" class="hidden" accept=".json">
            
            <button id="settingsBackButton" class="menu-button mt-8">BACK</button>
        </div>

        <!-- NEW: Boosting Text Overlay -->
        <div id="boostingText" class="hidden">BOOSTING</div>

    </div>
</div>

<script>
    // --- Local Storage Setup (Shared Keys) ---
    // These keys are shared with shop.html and stats.html
    const COIN_STORAGE_KEY = 'jetSurferTotalCoins';
    const MAGNET_LEVEL_KEY = 'jetSurferMagnetLevel';
    const JET_OWNED_KEY = 'jetSurferOwnedJets';
    const JET_SELECTED_KEY = 'jetSurferSelectedJet';
    const HEADSTART_COUNT_KEY = 'jetSurferHeadstartCount';
    const COIN_MULTIPLIER_LEVEL_KEY = 'jetSurferCoinMultiplierLevel';
    // --- NEW KEYS FOR STATS & QUESTS ---
    const HIGH_SCORE_KEY = 'jetSurferHighScore';
    const MONEY_SPENT_KEY = 'jetSurferMoneySpent';
    const QUEST_STORAGE_KEY = 'jetSurferQuests';

    // --- NEW: All storage keys for backup/restore ---
    const ALL_STORAGE_KEYS = [
        COIN_STORAGE_KEY, MAGNET_LEVEL_KEY, JET_OWNED_KEY, 
        JET_SELECTED_KEY, HEADSTART_COUNT_KEY, COIN_MULTIPLIER_LEVEL_KEY,
        HIGH_SCORE_KEY, MONEY_SPENT_KEY, QUEST_STORAGE_KEY
    ];





    // --- START: Jet Definitions ---
    // This array MUST match the one in shop.html
    const JETS = [
        { id: 'default', name: 'Standard Issue', price: 0, img: 'rec/motor/default.png' },
        { id: 'blue_streak', name: 'Blue Streak', price: 500, img: 'rec/motor/jet_blue.png' }, // Placeholder
        { id: 'red_comet', name: 'Nightwing', price: 1000, img: 'rec/motor/nightwing.png' }, // Placeholder
        { id: 'gold_wing', name: 'Premium Jet', price: 5000, img: 'rec/motor/premium-jet.png' }, // Placeholder
        { id: 'Punkin', name: 'Punkin', price: 10000, img: 'rec/motor/punkin.png' } // NEW JET
    ];
    const DEFAULT_JET_ID = 'default';
    
    let ownedJets = [DEFAULT_JET_ID];
    let selectedJetId = DEFAULT_JET_ID;
    // --- END: Jet Definitions ---

    let totalCoins = 0; // The persistent total
    let magnetLevel = 0; // The persistent magnet level (0 to 5)
    let headstartCount = 0; // The persistent headstart item count
    let coinMultiplierLevel = 0; // The persistent multiplier level

    function loadGameData() {
        const storedCoins = localStorage.getItem(COIN_STORAGE_KEY);
        // NEW: Check for first-time load
        if (storedCoins === null) {
            // It's the first time, give the player 150 coins as a welcome bonus
            totalCoins = 150;
            localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
        } else {
            // Not the first time, load existing coins
            totalCoins = parseInt(storedCoins, 10);
        }
        const storedMagnetLevel = localStorage.getItem(MAGNET_LEVEL_KEY);
        magnetLevel = storedMagnetLevel ? parseInt(storedMagnetLevel, 10) : 0;
        
        const storedHeadstartCount = localStorage.getItem(HEADSTART_COUNT_KEY);
        headstartCount = storedHeadstartCount ? parseInt(storedHeadstartCount, 10) : 0;
        
        const storedCoinMultiplierLevel = localStorage.getItem(COIN_MULTIPLIER_LEVEL_KEY);
        coinMultiplierLevel = storedCoinMultiplierLevel ? parseInt(storedCoinMultiplierLevel, 10) : 0;


        document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
        document.getElementById('headstartCount').textContent = headstartCount.toLocaleString();

        // --- Load Jet Data ---
        const storedOwnedJets = localStorage.getItem(JET_OWNED_KEY);
        ownedJets = storedOwnedJets ? JSON.parse(storedOwnedJets) : [DEFAULT_JET_ID];

        const storedSelectedJet = localStorage.getItem(JET_SELECTED_KEY);
        selectedJetId = storedSelectedJet ? storedSelectedJet : DEFAULT_JET_ID;
        
        // Apply the selected jet image
        const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
        playerImg.src = selectedJet.img;
        
        // Show/Hide Headstart button on start screen
        const headstartButton = document.getElementById('useHeadstartButton');
        document.getElementById('startHeadgetCount').textContent = headstartCount;
        if (headstartCount > 0) {
            headstartButton.classList.remove('hidden');
        } else {
            headstartButton.classList.add('hidden');
        }
    }

    function saveCoins(coinsEarned) {
        if (coinsEarned > 0) {
            totalCoins += coinsEarned;
        }
        localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
        document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
    }
    
    // --- Headstart Inventory Management ---
    function spendHeadstart() {
        if (headstartCount > 0) {
            headstartCount--;
            localStorage.setItem(HEADSTART_COUNT_KEY, headstartCount);
            document.getElementById('headstartCount').textContent = headstartCount;
            // Hide the button on the modal if no more are left
            if (headstartCount === 0) {
                document.getElementById('useHeadstartButton').classList.add('hidden');
            }
            return true;
        }
        return false;
    }
    // --- End Headstart Inventory Management ---

    // --- Jet/Coin Functions (Still needed for loading) ---
    function spendCoins(amount) {
        if (totalCoins >= amount) {
            totalCoins -= amount;
            localStorage.setItem(COIN_STORAGE_KEY, totalCoins);
            document.getElementById('totalCoinsValue').textContent = totalCoins.toLocaleString();
            return true; // Purchase successful
        }
        return false; // Not enough coins
    }

    function saveOwnedJets() {
        localStorage.setItem(JET_OWNED_KEY, JSON.stringify(ownedJets));
    }

    function saveSelectedJet() {
        localStorage.setItem(JET_SELECTED_KEY, selectedJetId);
        // Also update the playerImg.src immediately
        const selectedJet = JETS.find(j => j.id === selectedJetId) || JETS[0];
        playerImg.src = selectedJet.img;
        playerImg.isLoaded = false; // Force reload
        playerImg.onload = () => { playerImg.isLoaded = true; };
    }
    // --- End: Jet/Coin Functions ---

    function saveMagnetLevel(newLevel) {
        magnetLevel = newLevel;
        localStorage.setItem(MAGNET_LEVEL_KEY, newLevel);
        updateMagnetDuration(); // Recalculate duration when level changes
    }

    // --- NEW: Quest Notification Check ---
    function checkQuestCompletion() {
        const notificationIcon = document.getElementById('questNotificationIcon');
        if (!notificationIcon) return; // Exit if element not found

        const today = getTodayDateString();
        const storedQuests = localStorage.getItem(QUEST_STORAGE_KEY);
        let showNotification = false;

        if (storedQuests) {
            try {
                const questData = JSON.parse(storedQuests);
                // Only check if quests are for today
                if (questData.lastRefreshed === today) {
                    // Check if any quest is complete but not claimed
                    showNotification = questData.quests.some(quest => quest.isComplete && !quest.isClaimed);
                }
            } catch (e) {
                console.error("Failed to check quest completion:", e);
                showNotification = false;
            }
        }

        if (showNotification) {
            notificationIcon.classList.remove('hidden');
        } else {
            notificationIcon.classList.add('hidden');
        }
    }
    // --- End Quest Notification Check ---

    // --- NEW: Quest Progress Logic ---
    function getTodayDateString() {
        const now = new Date();
        return now.toISOString().split('T')[0]; // YYYY-MM-DD
    }

    function updateQuestProgress(type, amount) {
        const today = getTodayDateString();
        const storedQuests = localStorage.getItem(QUEST_STORAGE_KEY);
        
        if (!storedQuests) return; // No quests to update

        try {
            let questData = JSON.parse(storedQuests);

            // If quests are old, don't update progress
            if (questData.lastRefreshed !== today) {
                return;
            }

            let questsUpdated = false;
            questData.quests.forEach(quest => {
                if (quest.isClaimed || quest.isComplete) return; // Don't update completed or claimed quests

                let progressMade = false;
                if (quest.id === 'score_run' && type === 'score_run') {
                    quest.progress = Math.max(quest.progress, amount);
                    progressMade = true;
                } else if (quest.id === 'coins_run' && type === 'coins_run') {
                    quest.progress = Math.max(quest.progress, amount);
                    progressMade = true;
                } else if (quest.id === 'games_played' && type === 'play_game') {
                    quest.progress += amount;
                    progressMade = true;
                } else if (quest.id === 'total_coins' && type === 'total_coins') {
                    quest.progress += amount;
                    progressMade = true;
                } else if (quest.id === 'total_meters' && type === 'total_meters') {
                    quest.progress += amount;
                    progressMade = true;
                }

                if (progressMade) {
                    // Check for completion
                    if (quest.progress >= quest.target) {
                        quest.progress = quest.target; // Cap progress at target
                        quest.isComplete = true;
                    }
                    questsUpdated = true;
                }
            });

            if (questsUpdated) {
                localStorage.setItem(QUEST_STORAGE_KEY, JSON.stringify(questData));
                checkQuestCompletion(); // NEW: Update notification status
            }
        } catch (e) {
            console.error("Failed to update quest progress:", e);
        }
    }
    // --- End Quest Logic ---


    // --- Canvas Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');
    const rainEffect = new RainEffect(canvas); // Initialize rain effect

    // UI Elements
    const scoreValueElement = document.getElementById('scoreValue');
    const runCoinsValueElement = document.getElementById('runCoinsValue');
    const totalCoinsValueElement = document.getElementById('totalCoinsValue');
    const gameModal = document.getElementById('gameModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalMessage = document.getElementById('modalMessage');
    const startButton = document.getElementById('startButton');
    const finalScore = document.getElementById('finalScore');
    const coinsEarned = document.getElementById('coinsEarned');
    const useHeadstartButton = document.getElementById('useHeadstartButton');
    const reviveButton = document.getElementById('reviveButton'); // NEW: Revive button
    const boostingText = document.getElementById('boostingText');

    // UI Elements for Pause Menu
    const pauseButton = document.getElementById('pauseButton');
    const pauseMenuModal = document.getElementById('pauseMenuModal');
    const resumeButton = document.getElementById('resumeButton');
    const shopButton = document.getElementById('shopButton');
    const settingsButton = document.getElementById('settingsButton');
    const settingsModal = document.getElementById('settingsModal'); // NEW
    const settingsBackButton = document.getElementById('settingsBackButton'); // NEW
    const quitButton = document.getElementById('quitButton');

    // NEW UI ELEMENTS for Magnet
    const magnetProgressContainer = document.getElementById('magnetProgressContainer');
    const magnetProgressBar = document.getElementById('magnetProgressBar');

    // Game Constants
    const NUM_LANES = 3;
    const LANE_WIDTH_PERCENTAGE = 0.25;
    const PLAYER_SIZE = 60;
    const COLLISION_SIZE_RATIO = 0.7;
    const PLAYER_Y_POS_RATIO = 0.8;
    const PLAYER_MOVE_SPEED = 0.15;
    const INITIAL_GAME_SPEED = 4;
    const SPEED_INCREMENT_SCORE = 1000;
    const SPEED_INCREMENT_AMOUNT = 0.02;
    
    // Headstart Constants (NEW)
    const HEADSTART_SCORE = 50000;
    const HEADSTART_DURATION_SECONDS = 10;
    const HEADSTART_SPEED_MULTIPLIER = 20;
    
    // Magnet State Variables and Constants
    const MAGNET_DURATION_SECONDS_BASE = 10; // Base duration
    const MAGNET_DURATION_BONUS_PER_LEVEL = 2; // +2 seconds per level
    const MAGNET_MAX_LEVEL = 5;
    
    let currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE; // Actual duration used in game
    
    const MAGNET_BOOST_MULTIPLIER = 3.5;
    const MAGNET_SLOWDOWN_TIME_SECONDS = 2; 
    const MAGNET_SPAWN_CHANCE = 0.05; 

    // Dynamic Magnet Duration Calculation
    function updateMagnetDuration() {
        currentMagnetDuration = MAGNET_DURATION_SECONDS_BASE + (magnetLevel * MAGNET_DURATION_BONUS_PER_LEVEL);
    }
    
    // Initial calculation (must be called after loading magnetLevel)
    updateMagnetDuration(); 


    // State variables
    // Added 'BOOSTING' state
    let gameState = 'START'; // Possible states: 'START', 'PLAYING', 'PAUSED', 'SHAKING', 'GAMEOVER', 'BOOSTING'
    let score = 0;
    let runCoins = 0;
    let baseGameSpeed = INITIAL_GAME_SPEED;
    let currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
    let lastTime = 0;
    let deltaTime = 0;
    let lastObstacleTime = 0;
    let currentLane = 1;
    let targetLane = 1;
    let playerX = 0;
    let obstacles = [];
    let speedLevel = 0;

    let isMagnetActive = false;
    let magnetDurationMS = 0; // duration in milliseconds, set on activation
    let magnetStartTime = 0;
    let isSlowingDown = false;
    
    let shakeEndTime = 0;
    let reviveInvincibilityEndTime = 0; // NEW: For post-revive invincibility
    const SHAKE_MAGNITUDE = 10;
    const SHAKE_DURATION = 300;
    
    let boostEndTime = 0; // NEW: Headstart tracking

    // --- Background Styles (Updated for Red Theme) ---
    let explosions = []; // NEW: Array to hold explosion particles

    // --- NEW: Explosion Particle Class ---
    class ExplosionParticle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 8 + 4; // Particle size
            // Random velocity for a spray effect
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = (Math.random() - 0.5) * 12;
            this.alpha = 1; // Lifespan
            // Random color between orange, yellow, and red
            const colors = ['yellow', 'orange', 'yellow', 'orange'];
            this.color = colors[Math.floor(Math.random() * colors.length)];
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= 0.04; // Fade out
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    // Default background (Red)
    const DEFAULT_BACKGROUND = 'linear-gradient(16deg,rgba(187, 194, 196, 1) 0%, rgba(186, 186, 186, 1) 50%, rgba(237, 236, 232, 1) 100%)'; 
    // Darker, stormy, spaceous red gradient
    const RAIN_BACKGROUND = 'linear-gradient(0deg,rgba(48, 48, 48, 1) 0%, rgba(77, 77, 77, 1) 50%, rgba(230, 230, 230, 1) 100%)'; 

    // --- Canvas Background Styles (NEW) ---
    const SNOW_CANVAS_BACKGROUND = 'linear-gradient(16deg,rgba(187, 194, 196, 1) 0%, rgba(186, 186, 186, 1) 50%, rgba(237, 236, 232, 1) 100%)'; /* Light Blue Sky Gradient */
    const DARK_CANVAS_BACKGROUND = 'linear-gradient(0deg,rgba(48, 48, 48, 1) 0%, rgba(77, 77, 77, 1) 50%, rgba(230, 230, 230, 1) 100%)'; 
    
    // --- Rain State Variables ---
    let rainTimer = 0;
    let isRaining = false;
    const RAIN_CYCLE_DURATION_MS = 120 * 1000; // 120 seconds

    // Player/Coin Images
    const playerImg = new Image();
    // playerImg.src is set by loadGameData()
    playerImg.isLoaded = false;
    playerImg.onload = () => { playerImg.isLoaded = true; };
    playerImg.onerror = () => { 
        console.error("Failed to load selected jet image. Loading default.");
        playerImg.src = 'rec/motor/default.png'; // Fallback
        playerImg.isLoaded = false; // Re-trigger onload
        playerImg.onload = () => { playerImg.isLoaded = true; };
    };

    const coinImg = new Image();
    coinImg.src = "rec/items/coin.png"; 
    coinImg.isLoaded = false;
    coinImg.onload = () => { coinImg.isLoaded = true; };
    coinImg.onerror = () => { console.error("Failed to load coin image."); };
    
    const magnetImg = new Image();
    magnetImg.src = "rec/collectible/magnet.png"; 
    magnetImg.isLoaded = false;
    magnetImg.onload = () => { magnetImg.isLoaded = true; };
    magnetImg.onerror = () => { console.error("Failed to load magnet image. Using fallback."); };

    // --- Audio Setup ---
    const coinSound = new Audio('sfx/coin.mp3');
    const deathSound = new Audio('sfx/dead.mp3');
    const powerupSound = new Audio('sfx/powerup.mp3'); 
    const rainSound = new Audio('sfx/ambience/rain.mp3'); // Added rain sound
    const boostSound = new Audio('sfx/boost.mp3'); // NEW: Boost sound
    const backgroundMusic = new Audio('sfx/ambience/wind.mp3'); // NEW: Background music

    coinSound.volume = 0.6; 
    deathSound.volume = 1.0;
    powerupSound.volume = 0.6;
    rainSound.loop = true;
    rainSound.volume = 1.0; // Set rain volume to be ambient
    backgroundMusic.loop = true;
    backgroundMusic.volume = 1.0; // Lower volume so it's not overpowering
    boostSound.volume = 1.0;
    boostSound.loop = true;


    function playCoinSound() {
        coinSound.currentTime = 0; 
        coinSound.play().catch(e => console.error("Coin audio playback failed (expected if MP3 is missing):", e));
    }

    function playDeathSound() {
        deathSound.currentTime = 0; 
        deathSound.play().catch(e => console.error("Death audio playback failed (expected if MP3 is missing):", e));
    }

    function playPowerupSound() {
        powerupSound.currentTime = 0;
        powerupSound.play().catch(e => console.error("Powerup audio playback failed (expected if MP3 is missing):", e));
    }

    function playRainSound() {
        rainSound.play().catch(e => console.error("Rain audio playback failed (expected if MP3 is missing):", e));
    }
    
    function stopRainSound() {
        rainSound.pause();
        rainSound.currentTime = 0;
    }
    
    function playBoostSound() {
        boostSound.currentTime = 0;
        boostSound.play().catch(e => console.error("Boost audio playback failed (expected if MP3 is missing):", e));
    }
    
    function stopBoostSound() {
        boostSound.pause();
        boostSound.currentTime = 0;
    }
    
    function playBackgroundMusic() {
        // Only play if the game is active
        if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
            backgroundMusic.play().catch(e => console.error("Background music playback failed:", e));
        }
    }
    function stopBackgroundMusic() {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
    }


    // --- Object Classes (Unchanged) ---

    class Obstacle {
        constructor(lane, size, type = 'enemy') {
            this.lane = lane;
            this.size = size;
            this.y = -size;
            this.type = type;
            this.isHit = false;
        }

        update(speed, dt) {
            this.y += speed * dt;
        }

        draw(ctx, lanePos) {
            const xCenter = lanePos[this.lane];
            const y = this.y;

            if (this.type === 'enemy') {
                // Enemy Plane (Red/Black)
                ctx.fillStyle = this.isHit ? 'rgba(255, 0, 0, 0.8)' : 'rgba(239, 68, 68, 0.9)';
                ctx.beginPath();
                // Simple delta wing shape
                ctx.moveTo(xCenter, y);
                ctx.lineTo(xCenter - this.size / 2, y + this.size);
                ctx.lineTo(xCenter + this.size / 2, y + this.size);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(xCenter - this.size * 0.1, y + this.size * 0.2, this.size * 0.2, this.size * 0.5); // Cockpit
            } else if (this.type === 'coin') {
                // Coin
                if (coinImg.isLoaded) {
                    ctx.drawImage(coinImg, xCenter - this.size / 2, y, this.size, this.size);
                } else {
                    ctx.fillStyle = '#FFEB3B';
                    ctx.beginPath();
                    ctx.arc(xCenter, y + this.size / 2, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (this.type === 'magnet') {
                 // Magnet Power-up
                if (magnetImg.isLoaded) {
                    // Draw image if loaded
                    ctx.drawImage(magnetImg, xCenter - this.size / 2, y, this.size, this.size);
                } else {
                    // Fallback to a purple square with an icon
                    ctx.fillStyle = '#9333ea'; // Deep Purple
                    ctx.fillRect(xCenter - this.size / 2, y, this.size, this.size);
                    ctx.fillStyle = 'white';
                    ctx.font = `${this.size * 0.6}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ðŸ§²', xCenter, y + this.size / 2 + 2);
                }
            }
        }

        getBounds(lanePos) {
            const xCenter = lanePos[this.lane];
            return {
                x: xCenter - this.size / 2,
                y: this.y,
                width: this.size,
                height: this.size
            };
        }
    }

    // --- NEW: Function to create explosion particles ---
    function createExplosion(x, y, count = 40) {
        // Clear any previous explosion particles
        explosions = [];
        for (let i = 0; i < count; i++) {
            explosions.push(new ExplosionParticle(x, y));
        }
    }

    // --- Game Logic ---

    function setupCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        playerX = getLaneCenterX(currentLane);
        
        // Update rain effect canvas reference and re-init particles for new size
        rainEffect.canvas = canvas;
        if (isRaining) {
            rainEffect.init();
        }
    }

    function getLaneCenterX(laneIndex) {
        const laneWidth = canvas.width * LANE_WIDTH_PERCENTAGE;
        return (canvas.width / 2) + (laneIndex - 1) * laneWidth;
    }

    function getLaneCenters() {
        const centers = [];
        for (let i = 0; i < NUM_LANES; i++) {
            centers.push(getLaneCenterX(i));
        }
        return centers;
    }

    function spawnObstacle() {
        // Do not spawn enemies/magnets during a Headstart boost
        if (gameState === 'BOOSTING') {
            // Only allow coins to spawn during boost
            const lane = Math.floor(Math.random() * NUM_LANES);
            const size = 50;
            const type = 'coin';
            obstacles.push(new Obstacle(lane, size, type));
            return;
        }
        
        const lane = Math.floor(Math.random() * NUM_LANES);
        const size = 50;
        let type = 'enemy';

        const coinRoll = Math.random();

        if (coinRoll < 0.3) { // 30% chance of an item spawn
            const itemRoll = Math.random();
            // Only spawn a magnet if one isn't already active
            if (itemRoll < MAGNET_SPAWN_CHANCE && !isMagnetActive) { 
                type = 'magnet';
            } else {
                type = 'coin';
            }
        }
        obstacles.push(new Obstacle(lane, size, type));
    }

    function checkCollision(playerBounds, obstacle) {
        const obsBounds = obstacle.getBounds(getLaneCenters());

        return playerBounds.x < obsBounds.x + obsBounds.width &&
               playerBounds.x + obsBounds.width > obsBounds.x &&
               playerBounds.y < obsBounds.y + obsBounds.height &&
               playerBounds.y + obsBounds.height > obsBounds.y;
    }

    function getPlayerBounds(x) {
        const collisionSize = PLAYER_SIZE * COLLISION_SIZE_RATIO;
        const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
        return {
            x: x - collisionSize / 2,
            y: playerCenterY - collisionSize / 2,
            width: collisionSize,
            height: collisionSize,
            centerX: x,
            centerY: playerCenterY
        };
    }

    // Function to activate the magnet power-up
    function activateMagnet(currentTime) {
        isMagnetActive = true;
        isSlowingDown = false; 
        magnetStartTime = currentTime;
        magnetDurationMS = currentMagnetDuration * 1000; // Use dynamically calculated duration
        magnetProgressContainer.classList.remove('opacity-0');
        playPowerupSound();

        // Remove any other magnet power-ups currently on screen
        obstacles = obstacles.filter(obstacle => obstacle.type !== 'magnet');
    }
    
    // Function to end the magnet power-up cleanly
    function deactivateMagnet() {
        isMagnetActive = false;
        isSlowingDown = false;
        magnetProgressContainer.classList.add('opacity-0');
    }

    /**
     * Function to handle coin collection (still screen-wide)
     */
    function handleCoinCollection() {
        // Collect all coins during magnet or boosting
        if (!isMagnetActive && gameState !== 'BOOSTING') return;

        let collectedCount = 0;
        
        // Loop backwards to safely modify the array
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obstacle = obstacles[i];
            
            // Collect any non-hit coin
            if (obstacle.type === 'coin' && !obstacle.isHit) {
                obstacle.isHit = true; // Mark it as hit
                
                // *** FIX: CALCULATE COIN VALUE BASED ON MULTIPLIER ***
                const coinValue = 1 + coinMultiplierLevel; 
                
                // Magnet Level 5 bonus
                if (isMagnetActive && magnetLevel === MAGNET_MAX_LEVEL) {
                    runCoins += 15;
                } else if (gameState === 'BOOSTING') {
                    runCoins += 20; // Extra coin bonus during headstart
                } else {
                    runCoins += coinValue; // Use calculated coin value
                }

                collectedCount++;
            }
        }

        if (collectedCount > 0) {
            runCoinsValueElement.textContent = runCoins;
            // To prevent audio stuttering at high speeds, we only play it every 5th frame
            if (Math.floor(score) % 5 === 0) {
                playCoinSound(); 
            }
        }

        // Filter out collected coins (enemies and magnets remain)
        obstacles = obstacles.filter(o => o.type !== 'coin' || !o.isHit);
    }

    function drawGame(laneCenters, currentTime) {
        ctx.save();
        
        const isShaking = (gameState === 'SHAKING' && currentTime < shakeEndTime);
        if (isShaking) {
            const elapsed = shakeEndTime - currentTime;
            const progress = elapsed / SHAKE_DURATION; // Goes from 1 to 0
            const magnitude = SHAKE_MAGNITUDE * progress * progress; // Ease-out effect
            const x = (Math.random() - 0.5) * 2 * magnitude;
            const y = (Math.random() - 0.5) * 2 * magnitude;
            ctx.translate(x, y);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- Draw Rain Effect ---
        // Draw rain after clearing screen but before other elements
        if (isRaining) {
            rainEffect.draw(ctx);
        }
        // --- End Rain Effect ---

        // Draw lane lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 3;
        const lineOffset = (canvas.width * LANE_WIDTH_PERCENTAGE) / 2;
        ctx.beginPath();
        ctx.moveTo(getLaneCenterX(0) + lineOffset, 0);
        ctx.lineTo(getLaneCenterX(0) + lineOffset, canvas.height);
        ctx.moveTo(getLaneCenterX(2) - lineOffset, 0);
        ctx.lineTo(getLaneCenterX(2) - lineOffset, canvas.height);
        ctx.stroke();

        const playerCenterY = canvas.height * PLAYER_Y_POS_RATIO;
        const playerDrawX = playerX - PLAYER_SIZE / 2;
        const playerDrawY = playerCenterY - PLAYER_SIZE / 2;

        // Draw player jet
        if (playerImg.isLoaded) {
            // --- NEW: Dynamic Fire Exhaust Effect ---
            if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                const flameBaseY = playerDrawY + PLAYER_SIZE * 0.9; // Start flame just inside the jet
                const baseFlameWidth = PLAYER_SIZE * 0.4;

                // Create a flickering effect by varying height and width
                const flameHeight = (PLAYER_SIZE * 0.5) + (Math.random() * PLAYER_SIZE * 0.4);
                const flameFlickerWidth = baseFlameWidth + (Math.random() * 10 - 5);

                // Outer flame (yellow/orange)
                ctx.fillStyle = `rgba(255, ${180 + Math.random() * 55}, 0, 0.7)`;
                ctx.beginPath();
                ctx.moveTo(playerX - flameFlickerWidth / 2, flameBaseY);
                ctx.lineTo(playerX + flameFlickerWidth / 2, flameBaseY);
                ctx.lineTo(playerX, flameBaseY + flameHeight);
                ctx.closePath();
                ctx.fill();

                // Inner flame (brighter, smaller)
                const innerFlameHeight = flameHeight * 0.6;
                const innerFlameWidth = flameFlickerWidth * 0.5;
                ctx.fillStyle = `rgba(255, 255, 150, 0.9)`;
                ctx.beginPath();
                ctx.moveTo(playerX - innerFlameWidth / 2, flameBaseY);
                ctx.lineTo(playerX + innerFlameWidth / 2, flameBaseY);
                ctx.lineTo(playerX, flameBaseY + innerFlameHeight);
                ctx.closePath();
                ctx.fill();
            }

            // If magnet is active, draw a blue glow around the player
            if (isMagnetActive) {
                const maxBlur = 30;
                let blur = 0;
                if (isSlowingDown) {
                    const timeSlowing = (magnetStartTime + magnetDurationMS) - performance.now();
                    const ratio = timeSlowing / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                    blur = Math.max(0, maxBlur * ratio); 
                } else {
                    blur = maxBlur;
                }
                
                ctx.shadowColor = 'red';
                ctx.shadowBlur = blur;
            }

            // NEW: Draw a white shield/glow if invincible after reviving
            if (performance.now() < reviveInvincibilityEndTime) {
                const invincibilityProgress = (reviveInvincibilityEndTime - performance.now()) / 2000; // 2-second duration
                ctx.shadowColor = `rgba(255, 255, 255, ${0.8 * invincibilityProgress})`; // Fade out effect
                ctx.shadowBlur = 30 * invincibilityProgress;
            }

            ctx.drawImage(playerImg, playerDrawX, playerDrawY, PLAYER_SIZE, PLAYER_SIZE);
            ctx.shadowColor = 'transparent'; // Reset shadow
            ctx.shadowBlur = 0;
        } else {
            // Fallback drawing if image is still loading
            ctx.fillStyle = isMagnetActive ? '#2563eb' : '#3b82f6'; 
            ctx.beginPath();
            ctx.moveTo(playerX, playerDrawY);
            ctx.lineTo(playerDrawX, playerDrawY + PLAYER_SIZE);
            ctx.lineTo(playerDrawX + PLAYER_SIZE, playerDrawY + PLAYER_SIZE);
            ctx.closePath();
            ctx.fill();
        }

        // Draw obstacles
        obstacles.forEach(obstacle => obstacle.draw(ctx, laneCenters));
        
        // --- NEW: Draw Explosions ---
        explosions.forEach(p => p.draw(ctx));

        // When PAUSED, draw a semi-transparent dark overlay on top of the game
        if (gameState === 'PAUSED') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        ctx.restore();
    }

    // --- Game Control Functions ---
    
    function showModal(modalElement) {
        // Hide all modals
        gameModal.classList.add('hidden');
        pauseMenuModal.classList.add('hidden');
        settingsModal.classList.add('hidden'); // NEW: Hide settings modal

        
        // Show the requested modal
        modalElement.classList.remove('hidden');
    }

    function pauseGame() {
        if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
            const wasBoosting = gameState === 'BOOSTING';
            
            gameState = 'PAUSED';
            if (isRaining) rainSound.pause(); // Pause rain sound
            if (wasBoosting) stopBoostSound(); // Stop boost sound
            
            boostingText.classList.add('hidden'); // Hide text
            resumeButton.classList.remove('hidden'); // Show resume button in-game
            
            checkQuestCompletion(); // NEW: Check for quest notifications
            showModal(pauseMenuModal);
        } else if (gameState === 'START') {
            // Allow opening pause menu from the main screen
            resumeButton.classList.add('hidden'); // Hide resume button on main menu
            
            checkQuestCompletion(); // NEW: Check for quest notifications
            showModal(pauseMenuModal);
        }
    }

    function unpauseGame() {
        // If unpausing from the main menu, just hide the modal.
        if (gameState === 'START') {
            showModal(gameModal); // Hides pause menu, shows main menu
            return;
        }

        // If not in a paused state (e.g., from main menu), do nothing.
        if (gameState !== 'PAUSED') {
            return;
        }

        // Determine if we need to go back to BOOSTING or PLAYING
        const newGameState = (performance.now() < boostEndTime && score < HEADSTART_SCORE) ? 'BOOSTING' : 'PLAYING';
        gameState = newGameState;
        
        if (isRaining) playRainSound(); // Resume rain sound
        if (newGameState === 'BOOSTING') {
            playBoostSound();
            boostingText.classList.remove('hidden');
        }
        
        showModal(gameModal); // This hides all modals...
        gameModal.classList.add('hidden'); // ...so we explicitly hide the main one too.
        
        // Crucial: Reset lastTime to current time
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function initializeGame(useHeadstart = false) {
        // Reset state
        score = 0;
        runCoins = 0;
        baseGameSpeed = INITIAL_GAME_SPEED;
        currentEffectiveGameSpeed = INITIAL_GAME_SPEED;
        speedLevel = 0;
        obstacles = [];
        currentLane = 1;
        targetLane = 1;
        setupCanvas();
        playerX = getLaneCenterX(currentLane);
        
        // Set up headstart state
        if (useHeadstart) {
            score = HEADSTART_SCORE;
            gameState = 'BOOSTING';
            boostEndTime = performance.now() + (HEADSTART_DURATION_SECONDS * 1000);
            playBoostSound();
            boostingText.classList.remove('hidden');
        } else {
            gameState = 'PLAYING';
            boostEndTime = 0;
            boostingText.classList.add('hidden');
        }

        // Re-load data to ensure current magnet level and jet are used
        loadGameData(); 
        updateMagnetDuration();

        // Reset Magnet State
        deactivateMagnet();
        
        // --- UPDATED Rain Cycle Logic: Randomize Start ---
        const MAX_CYCLE_MS = RAIN_CYCLE_DURATION_MS * 2;
        rainTimer = Math.random() * MAX_CYCLE_MS; // Randomize start time
        isRaining = rainTimer < RAIN_CYCLE_DURATION_MS; // Check initial state
        
        rainEffect.stop();
        rainEffect.clear();

        // Set initial background and rain state based on the randomized start
        if (isRaining) {
            stopRainSound(); // Stop any previous instance before starting a new one
            rainEffect.start();
            playRainSound();
            document.body.style.background = RAIN_BACKGROUND; // Dark Red (Body)
            canvas.style.background = DARK_CANVAS_BACKGROUND; // New: Dark Red (Canvas)
        } else {
            document.body.style.background = DEFAULT_BACKGROUND; // Bright Red (Body)
            canvas.style.background = SNOW_CANVAS_BACKGROUND; // New: Snow Color (Canvas)
            // Stop sounds that shouldn't play when it's not raining
            stopRainSound();
            playBackgroundMusic(); // Start music if it's not raining
        }
        // --- END UPDATED Rain Cycle Logic ---
        
        shakeEndTime = 0;

        // Hide Modals and show Pause Button
        showModal(gameModal); // Hide all modals
        gameModal.classList.add('hidden'); // Then hide the main one
        finalScore.classList.add('hidden');
        coinsEarned.classList.add('hidden');
        scoreValueElement.textContent = Math.floor(score).toLocaleString(); // Update initial score
        runCoinsValueElement.textContent = '0';

        // --- NEW: Update 'Play Game' Quest ---
        if (!useHeadstart) { // Don't count headstart use as a "play" until they retry
            updateQuestProgress('play_game', 1);
        }
        // --- End Quest Update ---

        requestAnimationFrame(gameLoop);
    }
    
    // Wrapper function for the START button
    function startGame() {
        initializeGame(false);
    }
    
    // NEW function for Headstart button
    function startWithHeadstart() {
        if (spendHeadstart()) {
            initializeGame(true);
        } else {
            // Should not happen if button is correctly hidden/disabled
            console.error("Cannot use headstart: None left.");
        }
    }

    // NEW: Function to handle reviving the player
    function revivePlayer() {
        if (spendCoins(300)) {
            // --- NEW: Track money spent ---
            const storedSpent = localStorage.getItem(MONEY_SPENT_KEY);
            let moneySpent = storedSpent ? parseInt(storedSpent, 10) : 0;
            moneySpent += 300;
            localStorage.setItem(MONEY_SPENT_KEY, moneySpent);
            // --- END: Track money spent ---

            // Clear obstacles near the player to give them a safe start
            const playerY = canvas.height * PLAYER_Y_POS_RATIO;
            obstacles = obstacles.filter(obs => {
                const obsBottom = obs.y + obs.size;
                // Remove obstacles that are in the player's half of the screen
                return obsBottom < playerY - (canvas.height * 0.2) || obs.y > playerY + (canvas.height * 0.2);
            });

            // Grant 2 seconds of invincibility
            reviveInvincibilityEndTime = performance.now() + 2000;

            // --- NEW: Update 'Play Game' Quest on Revive ---
            // A revive counts as continuing the game, but let's count it as a "play"
            updateQuestProgress('play_game', 1);
            // --- End Quest Update ---

            // Resume the game
            gameState = 'PLAYING';
            gameModal.classList.add('hidden');
            pauseButton.classList.remove('hidden');
            lastTime = performance.now(); // Reset time to prevent frame jump
            requestAnimationFrame(gameLoop);
        }
    }


    function finishGameOver() {
        gameState = 'GAMEOVER';

        // Save persistent coins to local storage
        saveCoins(runCoins);
        
        // --- NEW: Save High Score ---
        const storedHighScore = localStorage.getItem(HIGH_SCORE_KEY);
        const highScore = storedHighScore ? parseInt(storedHighScore, 10) : 0;
        if (score > highScore) {
            localStorage.setItem(HIGH_SCORE_KEY, Math.floor(score));
        }
        // --- END: Save High Score ---

        // --- NEW: Update Quest Progress on Game Over ---
        updateQuestProgress('score_run', Math.floor(score));
        updateQuestProgress('coins_run', runCoins);
        updateQuestProgress('total_meters', Math.floor(score));
        if(runCoins > 0) {
            updateQuestProgress('total_coins', runCoins);
        }
        // --- End Quest Update ---
        
        // Stop all sounds/effects
        deactivateMagnet();
        if (isRaining) {
            isRaining = false;
            rainEffect.stop();
            stopBackgroundMusic(); // Also stop music on game over
            stopRainSound(); 
        }
        stopBoostSound(); // Stop any lingering boost sound from a previous run

        // Reset backgrounds
        document.body.style.background = DEFAULT_BACKGROUND; 
        canvas.style.background = SNOW_CANVAS_BACKGROUND;

        // Show Game Over Modal
        showModal(gameModal);
        modalTitle.textContent = "FLIGHT TERMINATED";
        modalMessage.textContent = "You collided with a enemy aircraft!";
        
        stopBackgroundMusic(); // Final stop just in case
        // Reload data to update headstart count on button
        loadGameData(); 
        
        // --- NEW: Revive Button Logic ---
        if (totalCoins >= 300) {
            reviveButton.classList.remove('hidden');
        } else {
            reviveButton.classList.add('hidden');
        }
        startButton.textContent = "RETRY";

        finalScore.textContent = `FINAL SCORE: ${Math.floor(score).toLocaleString()} meters`;
        finalScore.classList.remove('hidden');

        coinsEarned.textContent = `Coins Earned: $ ${runCoins}`;
        coinsEarned.classList.remove('hidden');
    }

    function gameOver() {
        // Can't game over during boost or post-revive invincibility
        if (gameState === 'BOOSTING' || performance.now() < reviveInvincibilityEndTime) return; 
        
        gameState = 'SHAKING';
        shakeEndTime = performance.now() + SHAKE_DURATION;
        playDeathSound();

        // --- NEW: Trigger explosion at player's last position ---
        createExplosion(playerX, canvas.height * PLAYER_Y_POS_RATIO);
    }


    // --- Game Loop ---
    function gameLoop(currentTime) {
        if (gameState === 'START' || gameState === 'GAMEOVER') {
            lastTime = currentTime;
            return;
        }
        
        if (gameState === 'PAUSED') {
             drawGame(getLaneCenters(), currentTime);
             return;
        }

        deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // --- NEW: Update and filter explosion particles ---
        explosions.forEach(p => p.update());
        explosions = explosions.filter(p => p.alpha > 0);
        
        // --- Check for Headstart Boost Expiration (NEW) ---
        if (gameState === 'BOOSTING') {
            if (currentTime > boostEndTime) {
                gameState = 'PLAYING'; // End boost
                stopBoostSound();
                boostingText.classList.add('hidden');
            } else if (score >= HEADSTART_SCORE) {
                // If the score already reached the target, switch to normal speed
                gameState = 'PLAYING';
                stopBoostSound();
                boostingText.classList.add('hidden');
            }
        }
        
        // --- Rain Cycle Logic ---
        rainTimer += (deltaTime * 1000);
        
        if (rainTimer >= RAIN_CYCLE_DURATION_MS * 2) {
            rainTimer -= (RAIN_CYCLE_DURATION_MS * 2); // Reset cycle (240s total)
        }
        
        if (rainTimer < RAIN_CYCLE_DURATION_MS) {
            // First 120 seconds: Raining
            if (!isRaining) {
                isRaining = true; // Set state to raining
                rainEffect.start();
                playRainSound(); // Start rain sound
                stopBackgroundMusic(); // Stop music when rain starts
                document.body.style.background = RAIN_BACKGROUND; // Change body to Dark Red
                canvas.style.background = DARK_CANVAS_BACKGROUND; // Change canvas to Dark Red/Black
            }
        } else {
            // Second 120 seconds: Cooldown
            if (isRaining) {
                isRaining = false;
                rainEffect.stop();
                stopRainSound(); // Stop rain sound
                if (gameState === 'PLAYING') playBackgroundMusic(); // Start music when rain stops during gameplay
                document.body.style.background = DEFAULT_BACKGROUND; // Revert body to Bright Red
                canvas.style.background = SNOW_CANVAS_BACKGROUND; // Revert canvas to Snow Color
            }
        }

        if (isRaining) {
            rainEffect.update(); // Update particle positions
        } else {
            rainEffect.clear(); // Clear particles when not raining
        }
        // --- End Rain Cycle Logic ---
        
        const laneCenters = getLaneCenters();

        if (gameState === 'SHAKING') {
            if (currentTime > shakeEndTime) {
                finishGameOver();
                return;
            }
            
            // Obstacles still move during shake
            obstacles = obstacles.filter(obstacle => {
                obstacle.update(currentEffectiveGameSpeed * 60, deltaTime);
                return obstacle.y < canvas.height;
            });
            
            drawGame(laneCenters, currentTime);
            requestAnimationFrame(gameLoop);
            return;
        }

        // --- 'PLAYING' or 'BOOSTING' state ---
        const playerBounds = getPlayerBounds(playerX);

        // 1. Update Base Game Speed
        if (gameState !== 'BOOSTING') {
            const newSpeedLevel = Math.floor(score / SPEED_INCREMENT_SCORE);
            if (newSpeedLevel > speedLevel) {
                speedLevel = newSpeedLevel;
                baseGameSpeed = INITIAL_GAME_SPEED * (1 + (speedLevel * SPEED_INCREMENT_AMOUNT));
            }
        } else {
            // If boosting, base speed is high
            baseGameSpeed = INITIAL_GAME_SPEED * (1 + (HEADSTART_SCORE / SPEED_INCREMENT_SCORE) * SPEED_INCREMENT_AMOUNT);
        }

        // 2. Update Effective Game Speed (Magnet/Headstart Effect)
        let speedMultiplier = 1;
        
        if (gameState === 'BOOSTING') {
            speedMultiplier = HEADSTART_SPEED_MULTIPLIER;
        } else if (isMagnetActive) {
            const timeElapsed = currentTime - magnetStartTime;
            const timeLeft = magnetDurationMS - timeElapsed;
            
            if (timeLeft <= 0) {
                deactivateMagnet();
            } else if (timeLeft <= MAGNET_SLOWDOWN_TIME_SECONDS * 1000) {
                isSlowingDown = true;
                const slowDownRatio = timeLeft / (MAGNET_SLOWDOWN_TIME_SECONDS * 1000);
                const speedRange = MAGNET_BOOST_MULTIPLIER - 1;
                speedMultiplier = 1 + (speedRange * Math.max(0, slowDownRatio)); 
            } else {
                speedMultiplier = MAGNET_BOOST_MULTIPLIER;
            }

            const progress = (timeLeft / magnetDurationMS) * 100;
            magnetProgressBar.style.width = `${progress}%`;

        } else {
            isSlowingDown = false;
        }
        
        currentEffectiveGameSpeed = baseGameSpeed * speedMultiplier;
        
        // 3. Score Update
        score += currentEffectiveGameSpeed * 10 * deltaTime; 

        // 4. Update Player Position
        const targetX = getLaneCenterX(targetLane);
        playerX += (targetX - playerX) * PLAYER_MOVE_SPEED;
        if (Math.abs(playerX - targetX) < 1) {
            currentLane = targetLane;
        }

        // 5. Update Obstacles
        obstacles = obstacles.filter(obstacle => {
            obstacle.update(currentEffectiveGameSpeed * 60, deltaTime);
            return obstacle.y < canvas.height;
        });

        // 6. Spawn new obstacle
        if (currentTime - lastObstacleTime > 1600 / (currentEffectiveGameSpeed * 0.8)) {
            spawnObstacle();
            lastObstacleTime = currentTime;
        }

        // 7. Coin Collection Logic (during Magnet or Boost)
        handleCoinCollection();
        
        // 8. Collision Detection
        obstacles.forEach(obstacle => {
            if (!obstacle.isHit && checkCollision(playerBounds, obstacle)) {
                obstacle.isHit = true;
                
                if (obstacle.type === 'enemy') {
                    // Collision only results in game over if not boosting or not under magnet protection
                    if (gameState !== 'BOOSTING' && !isMagnetActive && performance.now() > reviveInvincibilityEndTime) {
                        gameOver();
                    }
                    // If boosting or magnet is active, the enemy is destroyed (filtered out next step)
                } else if (obstacle.type === 'coin') {
                    // If not caught by magnet logic in handleCoinCollection, still collect on contact
                    if (!isMagnetActive) {
                         // *** FIX: CALCULATE COIN VALUE BASED ON MULTIPLIER ***
                         const coinValue = 1 + coinMultiplierLevel;
                         if (magnetLevel === MAGNET_MAX_LEVEL) {
                            runCoins += 15;
                        } else {
                            runCoins += coinValue; // Use calculated coin value
                        }
                        runCoinsValueElement.textContent = runCoins;
                        playCoinSound();
                    }
                } else if (obstacle.type === 'magnet') {
                    activateMagnet(currentTime);
                }
            }
        });

        // 9. Remove collected/destroyed items
        // Destroyed enemies are filtered out here if isHit is true (due to protection)
        obstacles = obstacles.filter(o => (o.type !== 'coin' && o.type !== 'magnet' && o.type !== 'enemy') || !o.isHit);

        // 10. Draw
        drawGame(laneCenters, currentTime);

        // 11. Update UI
        scoreValueElement.textContent = Math.floor(score).toLocaleString();

        requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners & Initialization ---

    // 1. Handle resize
    window.addEventListener('resize', setupCanvas);

    // 2. Start Buttons (Updated)
    startButton.addEventListener('click', startGame);
    useHeadstartButton.addEventListener('click', startWithHeadstart);
    reviveButton.addEventListener('click', revivePlayer); // NEW

    // 3. Pause Button & Menu Handlers
    pauseButton.addEventListener('click', pauseGame);
    resumeButton.addEventListener('click', unpauseGame);
    quitButton.addEventListener('click', finishGameOver); // NEW: Quit button ends the run
    
    shopButton.addEventListener('click', () => {
        gameState = 'PAUSED'; 
        window.location.href = 'shop.html';
    }); 
    
    // --- NEW: Settings Menu Logic ---
    settingsButton.addEventListener('click', () => {
        showModal(settingsModal); // Show the new settings modal
    });

    settingsBackButton.addEventListener('click', () => {
        showModal(pauseMenuModal); // Go back to the pause menu
    });

    // --- NEW: Data Export/Import Logic ---
    const exportDataButton = document.getElementById('exportDataButton');
    const importDataButton = document.getElementById('importDataButton');
    const importFileInput = document.getElementById('importFileInput');

    exportDataButton.addEventListener('click', () => {
        const backupData = {};
        ALL_STORAGE_KEYS.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) {
                backupData[key] = value;
            }
        });

        const jsonString = JSON.stringify(backupData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `jetsurfers-backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert("Backup file has been downloaded!");
    });

    importDataButton.addEventListener('click', () => {
        importFileInput.click(); // Trigger the hidden file input
    });

    importFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                ALL_STORAGE_KEYS.forEach(key => {
                    if (importedData[key] !== undefined) {
                        localStorage.setItem(key, importedData[key]);
                    }
                });
                alert("Data imported successfully! The game will now reload to apply changes.");
                window.location.reload();
            } catch (error) {
                alert("Import failed: The selected file is not a valid backup file.");
            }
        };
        reader.readAsText(file);
    });

    // 4. Input Handling
    function handleInput(isRight) {
        if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
            if (isRight && targetLane < NUM_LANES - 1) {
                targetLane++;
            } else if (!isRight && targetLane > 0) {
                targetLane--;
            }
        }
    }

    // --- Swipe Detection State ---
    let touchStartX = 0;
    let touchStartY = 0;

    // Keyboard Input
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
            handleInput(true);
        } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
            handleInput(false);
        } else if (e.key === 'Enter' && gameState !== 'PLAYING' && gameState !== 'BOOSTING') {
            if (gameState === 'PAUSED') {
                // Check which modal is open.
                if (!pauseMenuModal.classList.contains('hidden')) {
                   // In pause menu, don't unpause with Enter
                   return;
                }
                unpauseGame();
            } else if (gameState === 'GAMEOVER' || gameState === 'START') {
                startGame();
            }
        } else if (e.key === 'Escape' || e.key.toLowerCase() === 'p') {
            if (gameState === 'PLAYING' || gameState === 'BOOSTING') {
                pauseGame();
            } else if (gameState === 'PAUSED') {
                // If in pause menu, unpause
                if (!pauseMenuModal.classList.contains('hidden')) {
                    unpauseGame();
                }
            } 
        }
    });

    // Touch/Click Input (Mobile friendly)
    canvas.addEventListener('mousedown', (e) => { // Keep for desktop clicking
        if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        handleInput(x > canvas.width / 2); // True if tapped on the right half
    });
    
    // --- NEW: Swipe Controls for Mobile ---
    canvas.addEventListener('touchstart', (e) => {
        if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
        e.preventDefault();
        // Record the starting touch position
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchend', (e) => {
        if (gameState !== 'PLAYING' && gameState !== 'BOOSTING') return;
        e.preventDefault();
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const minSwipeDistance = 30; // Minimum pixels for a swipe

        // Check for a horizontal swipe that is long enough
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
            handleInput(deltaX > 0); // True for right swipe, false for left
        }
    });

    // Start initialization and game loop on load
    window.onload = function() {
        loadGameData(); // Load all persistent data (coins, magnet level, jets, and headstarts)
        updateMagnetDuration(); // Ensure the duration is correct on startup
        setupCanvas();
        
        // Initialize background to default state on load
        document.body.style.background = DEFAULT_BACKGROUND; 
        canvas.style.background = SNOW_CANVAS_BACKGROUND;
        
        checkQuestCompletion(); // NEW: Check for quest notifications
        
        requestAnimationFrame(gameLoop);
    }

</script>
</body>
</html>
